{
  "success": true,
  "bv_id": "BV1TSg7zuEqR",
  "url": "https://www.bilibili.com/video/BV1TSg7zuEqR/",
  "content": "今天我们来聊聊agent，它也叫AI agent，这是一个随着大模型热潮而兴起的重要概念，虽然agent这个词现在被频繁的提起，但它究竟是什么，是如何运作的，很多人其实并不清楚。所以在这个视频里面，我会带你彻底搞明白这两个问题。在正式开始前，我需要先提醒一下，视频前半部分的一些内容和我之前发过的mp终极指南番外篇有所重合。如果你已经看过那一篇了，那这个视频就建议从react代码的实现部分开始观看。大家都知道现在的大模型，比如gp 4o deep sick之类的，他们回答问题很厉害，逻辑也很强，但平时我们用他们的时候呢，会发现一个限制，他们无法感知或者是改变外界环境。这句话是什么意思呢，我举一个例子来给你说明一下，比如你想让gb 4o帮你写一个贪吃蛇游戏，他确实可以给你代码，但是写完之后，像把代码写入到文件这种事情还是得你自己动手。也就是说，大模型无法改变外界环境，而且有没有一种可能，你其实已经有一些贪吃蛇的代码了，你只是想让模型帮你基于这些代码来改写，增加一些功能，在这种情况下，你就必须把你已有的代码复制给GBD4O才行。我们不主动告诉GBD4O的话，他是无法自己查到这些代码的，换句话说，这就是大模型无法感知外界环境的体现，所以综合来看，大模型是无法感知或者是改变外部环境的。那有没有办法解决掉这个问题呢？其实是有的，我们给他接上对应的工具就可以了。比如说是读写文件内容的工具，查看文件列表的工具，运行终端命令的工具。工具呢就像是大模型的感官和四肢，有了它大模型就可以自己查询已有文件，自己写入代码，自己运行程序，整个过程不需要我们插手，完全自动化，像这样把一个大模型和一堆工具组装起来，变成一个能感知和改变外界环境的智能程序，我们就称它为agent。通常agent用一个机器人来表示，这与大模型的大脑图标形成了鲜明的对比，毕竟agent有了感官和四肢嘛，能自己独立做事了，就像一个机器人一样。Agent呢有很多类型，前面举的是编程类的agent，它可以用来开发程序。除此之外还有一些agent可以做P T，有一些agent可以深度搜索等等等等。总的来说agent的类型有很多，擅长的领域呢也各不相同。下面我们来举几个具体点的例子。第一个例子便是大名鼎鼎的cursor。相信即使你没有使用过它，也多多少少听说过它的存在。Cursor是一个用于编程的agent，我们只需要给他提交任务，它便会调用大模型和各种工具来帮我们写代码，直至完成任务。整个过程中，你顶多点个确定按钮，别的基本上什么也不用动。再举一个例子，前一阵子比较火的minus它也是一个agent。在这个例子中用户希望minus帮他比较几个手机的性能、照相等能力。为了解决用户的问题，minus会生成执行计划，搜索并浏览相关网页，最后把报告整理成一个页面展示给用户看，整个过程基本上也不需要用户插手，minus利用大模型和一些工具就可以解决掉用户的问题。好，相信到这里呢你对agent就有一个大致的了解了。下面呢我们就来讲讲agent的运行模式。Agent的运行有很多种模式，其中最有名的一种是react。React本身是一个缩写，它的全称是reasoning and acting，也就是思考与行动。React可能是目前使用最为广泛的agent运行模式。如果你要学习agent的实现原理，那你就绝对绕不开react，这个模式最初由2022年10月份的一篇论文提出，虽然距离现在已经有接近三年的时间了，但是他所提出的agent的运行模式仍然有着非常广泛的使用。说他是目前使用最为广泛的A城的运行模式也不为过。在这种模式下，用户先提交任务，然后agent先做思考，英文是thought，他思考后会决定是否调用工具，如果是的话，他便会去调用合适的工具，比如读取文件，写入文件内容之类的。React称这一步是行动，英文是action。在行动后，agent会去查看工具的执行结果，比如所读取的文件内容，写入是否成功等等。React称这一步是观察，也就是观察工具执行结果。英文是observation，在观察之后，react会继续思考，他会再次判断是否需要调用工具，如果还是需要的话，他就会继续重复之前所说的行动观察思考的流程，直到某个时刻他认为不需要再调用工具了，可以直接给出结论了。此时他就输出了最终答案，英文是final answer，整个流程到此结束。所以从这个流程图里面也可以看出，react流程的核心步骤是thought、action、observation和final answer。记住这几个词，我们后面呢会用到。了解了react模式的流程之后，下一个问题就是这种react模式是如何实现的。为什么模型拿到用户问题之后会先思考再行动？他为什么不直接行动？是因为模型就这么训练的吗？不是的这跟模型的训练过程关系不大。大部分奥秘呢其实都集中在系统提示词上。系统提示词是跟用户问题一起送给模型的提示词。他规定了模型的角色运行时要遵守的规则，以及各种环境的信息等等。比如我们在系统提示词里面写，你的回答必须包含两个excl标签，一个叫做question，用于存放用户的问题，一个叫做answer，用于存放你的回答，你把这个系统提示词和用户问题一起发给大模型。在这种情况下，大模型便会遵循这种规范来输出答案。上面举的是一个简单的例子，如果你想要模型按照react模式返回答案的话呢，那你的系统提示词就会更加复杂一些。我这里呢就有一个具体点的例子，这个系统提示词大致有五个部分，分别是职责描述事例、可用工具、注意事项和环境信息。我们来仔细读一下。首先看职责描述部分，你需要解决一个任务，为此你需要将任务分解为多个步骤。对于每个步骤首先使用thought思考要做什么，然后使用action调用一个工具，工具的执行结果会通过observation返回给你持续这个思考和行动的过程，直到你有足够多的信息来提供final answer。这一段话呢其实就是在描述我们刚才的那个react执行流程图。我们希望大模型按照react这个标准来运作。后面呢则是专门说明了每个标签的功能。紧接着我举了几个例子，比如说第一个用户的问题是埃菲尔铁塔有多高？模型呢就先用thought标签做了一些思考，然后再使用action调用了get he工具常用的参数呢是埃菲尔铁塔工具的返回结果通过observation返回给了模型。模型接到结果之后呢，他再做了一些思考，然后就给出了最终的答案，这个就是一个非常典型的react流程。后面的例子二呢其实也是类似，只不过是他调用工具调了两遍啊，这个我们就不细说了。再往后我这里列举了一些可用的工具，分别用于读取文件内容，写入文件内容和运行终端命令，都是非常常用的功能，然后呢我们列举了一些注意事项就是在这里，而且告诉了大模型相关的一些环境信息，比如说是当前的操作系统目录和目录下的文件列表等等。下面我们就来演示一下如何使用这个系统提示词。我们用deep stick来举例，我们先把我们的系统提示词复制一下，然后粘贴进来作为用户输入的一部分。之后再在后面加上具体要完成的任务，写一个贪吃蛇游戏，使用htm l css和J S实现代码分别放在不同的文件中。有一点需要提一下，按照规范的做法，系统提示词和用户任务应该分开传给模型。但deep并没有提供单独提交系统提示词的地方，所以呢我们就把系统提示词和用户任务合在一起，当成一条消息提交给他。这样的处理方式在大多数的情况下也是没有问题的，模型依然能够按照预期运行。好，让我们提交任务，可以看到deep ck开始运行了让我们稍等一下，让他运行完毕。可以看出他按照我们的要求先在source标签里面思考了一下，然后他使用action标签请求调用right above工具来写入index dtl文件，这后面就是具体的文件内容了，大家注意我的措辞啊，大模型请求调用工具这里体现的是请求两个字，大模型本身是不能调用工具的，调用工具的是agent的工具，调用组件这里大模型只能是请求。现在如果运行的是一个真的agent的话，它便会去调用工具背后的right form函数写入H tm l文件内容。不过我们现在的模拟嘛，我们就假设调用已经完成了，并且假设工具的返回结果是写入成功，所以我们回复observation写入成功。拿到这个结果后，deep stick又开始运行了，这次他还是先用thought标签思考了一下，然后再使用action标签请求写入css文件的内容。我们照例回复写入成功，deep sick又开始返回了让我们稍等一下。可以看出deep Seeck还是先用thought思考，再用action请求写入gs s文件的内容，我们还是回复写入成功，然后deep sick的返回就有了些变化，因为三个必要的文件都已经写入完成了，不需要再调用工具了，因此deep Seeck的thought之后返回了一个final answer，整个回答就彻底结束了。你看，这就是react模式真正运行时的节奏，每一步都按照系统提示词的要求来，thought action observation, thought action observation, 一直到任务完成，此时会输出thoughts和final answer。系统提示词就相当于给模型安排了一个迷你剧本，他会严格按照这个剧本一步一步的走完。前面我们用deep演示了一个agent的运行流程，可以看到整个流程的关键在于系统提示词，它决定了模型该如何一步步运行。其实在这个系统提示词的基础上，再加上一些配套的代码，我们就可以搭建出一个真正可用的react agent。实际上我已经把这个agent写好了，就放在我的get help仓库里，有需要的同学可以自行获取。接下来我先演示一下这个agent的使用过程，随后再带大家一起看一遍它的代码。我已经进入到这个agent所处的项目目录了，我们先执行一下命令，看一下这个项目目录里面都有什么文件。这里文件很多啊，但实际上你只有两个文件需要留意一下。第一个是agent的pi文件，这个文件里面就写了我们的agent的代码，我们等会儿要运行的就是这个文件。另外一个是snake文件夹，它里面什么也没有。我用tree命令给你证实下，可以看出确实没有任何文件。等会儿我就会让agent把代码写入到这个文件夹里面。好，介绍完毕。下面我们来执行一下这个agent，让你看看他是如何运作的。首先我们启动一下这个agent，我们用的命令是uv run agpi snake。前面的uv run agent pe就是用来启动agent的pi文件的，后面的snake是agent pi这个脚本的第一个参数，意思是告诉agent的p他要操作的项目目录是snake代码就写在那里面，agent点p首先向我们询问需要完成的任务，我们的任务就是写一个贪吃蛇游戏。使用htm l css和J S实现代码分别放在不同的文件中回agent p已经开始运行了，它现在正在请求大模型，我这里采用了同步返回的机制，所以需要等模型把所有内容都生成完毕之后才能看到结果。其实也可以用流式返回的模型，返回几个字就能看到几个字，这样可能效果更好一点。不过代码的复杂度会增加，所以综合权衡之后我就没有使用流式返回。好看到第一轮的结果了。我们的结果一共是包含三个部分，thoughts、action、observation, 跟我们之前在deep sick那里看到的一模一样。这里的action是请求调用right for工具写入index点H tl文件后面的observation显示的就是具体的调用结果了。写入成功。注意啊，这个写入成功可不是模拟的这是真的执行了right for工具，工具也真的返回了写入成功这几个字。好，这个呢是第一部分，我们把滚动条往下拉一拉，看一下剩下的部分是个什么样子的。后面的流程呢也基本类似，可以看到在observation之后，agent会再次进修模型。然后agent就又进行了一段thought action observation，这一轮写入的是css我们再把滚动条往下拖一拖，在这里我们就可以看到第三轮的thought action observation，这次写入的是js最后所有文件都写完之后，他会给出thoughts和final answer，整个流程就结束了。再看看snake文件夹，确实三个文件都有了。执行index H天喵，看看游戏能不能玩。可以看到界面出来了，我们动一下啊，确实也是能动的。然后是一个红色的方块呢，也是可以吃的。左上角是分数，看来运转的非常顺畅。从这个结果中也可以判断出我们这个agent做的非常成功，完全可以作为一个简化版的cloud code来使用。下面我们来看一下这个agent的具体代码。我们首先从入口处看起，这里面的project directory就是我们传给agent的p文件的第一个参数，也就是snake那个文件夹。Tools代表可用的工具列表。我们这里给出了三个，分别用于读取文件、写入文件和运行终端命令。这些都是很实用的函数。我们可以大体看一下，这个呢是读取文件，这个是写入文件函数，这个呢是运行终端命令。从这里也可以看出，工具确实就是函数。让我们回到原来的主链路继续往下看，这里的react agent便是这个文件的核心了。它是一个类构造这个类的时候呢需要提供三个参数。第一个是工具列表，这个我们前面已经构建好了，这里直接传了进来。第二个是我们要用的模型，我们这里用的是gb d 4O第三个是项目目录，也就是snake文件夹。传好了这三个参数之后，我们便获取到了一个agent变量之后我们会提示用户输入任务内容。然后我们把用户任务传入agent点run函数，这个函数是react agent的核心，调用它就相当于是启动了这个agent。之前提到的thoughts，action, observation和final answer都是在这个函数内部意思处理的。他处理好了之后会给出一个最终答案，final answer, 并且把这个final answer输出到屏幕上，到这里主链路就结束了。可以看到这段代码的核心是react agents，我们来看一下它里面写了些什么。首先他这里定义了一些自身的属性，分别是工具列表、模型项目目录和模型调用客户端。到这里构造函数呢就结束了。后面我们要看的函数便是这个agent的重点run函数。这个函数的参数呢是用户输入的任务，在函数的内部它先构建了一个message列表，里面有两个元素，分别是系统提示词和用户问题。系统提示词是用render system prompts这个函数来渲染的。他接受一个参数是系统提示词模板，模板里面的内容是这个样子的，跟我们之前讲的那个系统提示词基本上是一样的。只不过这个模板里面有一些站位符，比如说是工具列表，操作系统当前目录下的文件列表等等。这些站位符都是render system prompt函数在运行的时候填进去的。在拼接好了message列表之后，我们使用call model函数调用了模型，拿到了模型的执行结果。然后我们提取出返回结果中的thought部分，并且打印了出来。然后代码会检测thought之后的内容是不是final answer，如果是的话，我们返回这个final answer函数执行到此结束。如果不是的话，那constant里面一定就包含action了。我们此时就把action给解析出来，提取出其中的函数名和参数列表，然后判断了一下当前工具是不是运行终端命令的工具。如果是的话，我们会提示用户是否继续。因为运行终端命令比较危险，所以现在一般用于编程的agent的都会在运行终端命令之前主动询问用户是否要执行。之后没有问题的话呢，我们就会去执行工具背后的函数了。并且把执行结果放到observation里面，再把observation放到message列表里面。因为我们在一个one循环里面，所以呢我们下一步还会来到循环的开头。这里继续请求模型，我们给call model这个函数传了message列表作为参数工具，执行结果不是作为observation放到了message列表里面了吗？而message又传给了模型，这样模型就可以拿到工具的执行结果了，他进而就可以根据工具的执行结果推测下一步要干什么。所以总结一下这个while循环做的事情，请求模型提取thoughts，检测final answer，提取action并执行其中的工具。这个过程会一直重复下去，直到模型返回了final answer位止。回想一下，这正是我们之前所提到的react运行流程。为了确保你彻底明白这其中发生了什么，我们来画个agent的流程图。整个流程图里面有两个角色，用户和agent。而agent又可以分成三个部分，分别是模型、工具，也就是函数，还有agent主程序。Agent主程序这个词我们之前没有提过，其实就是agent里面负责串联整个流程的代码逻辑，它会在合适的时候调用工具或者是模型等等。你可以大致理解为我们刚才代码里面的那个ra函数，下面我们就来画个流程图，看看这四个角色之间是怎么沟通的。在用户提交任务之后，任务先到了agent的主程序这里。Agent的主程序会先去调用模型，模型返回thought和action。Agent的主程序把thought和action打印给用户看，然后去调用action里面的指定工具，工具执行完毕之后返回结果。Agent的主程序把结果发挥给用户看，然后把这个工具执行结果加入到历史消息列表里面，然后再次重复这个框中的流程，也就是请求模型并处理thought，action和observation的逻辑。直到某个时刻，在请求模型后，模型认为用户的任务已经完成了，不需要再利用工具了，他就会返回thoughts和final answer。Agent的主程序把thoughts和final answer展示给用户看，整个流程就结束了。这就是一个完整的react agent的问答流程。前面我们讲了如何使用react模式来构建一个agent。React是目前最常见，使用最广泛的agent的构建模式，但它不是唯一的方案。除了react之外，还有很多其他的运行模式，其中很多agent的运行过程就是先规划再执行。比如我们之前演示过的minus，如果你仔细看的话就会发现他在一开始回答的时候会构建一个待办列表，后面的执行过程呢都是遵循这个代办列表来。而cloud code中也会经常看到这种先创建to do再去执行的情况。这种先规划再执行的模式，目前并没有一个统一的名字。而且每个agent的实现多多少少也会有些差别。我们今天来讲一个其中比较有名的实现是郎提出来的plan and execute模式。从总体上来看，他也是遵循了先规划再执行的流程。只不过他的流程引入了一些动态修改规划的环节，这使得他的方案有了很大的灵活性。我们先用实习图来画一下plan and execute模式的运行流程。首先我们要搞清楚这个实习图里面有多少个角色，粗分下来的话，那肯定只有两个了，一个是用户，另外一个呢是plan excuse agent。不过既然要研究plan excagent的运行流程，我们就肯定要搞清楚这个agent的组成部分。首先它里面有一个负责出执行计划的模型，我们称它为plan模型。我们在运行的过程中还需要根据每一步的执行结果来动态的调整计划。因此我们还需要一个负责修改执行计划的模型，我们称它为replan模型。Plan和replan模型可以是同一个，也可以分成两个，都是可以的，我们暂且将它们列为两个。除了这两个模型之外，我们还需要一个负责执行这个计划中每一个步骤的agts，我们称它为执行agenent。对，你没看错这个plan excuse agents内部呢还有一个agent，这种agent套agent的设计方案其实也是比较常见的。最后跟react那个流程一样，我们还需要一个agent的主程序负责串联整个流程，这就是plan excuse agent的全部模块了。下面我们就把它们放在流程图里面，看看各个模块之间是如何运作的。首先用户会把问题提给agent的主程序，比如我们的问题就可以是今年澳网男子冠军的家乡是哪里，这里的澳网指的是每年举办的澳大利亚网球公开赛，也就是个体育赛事了。Agent的主程序接到这个问题之后，会把这个问题发给plan模型，让他给出具体的执行步骤。比如一个可能的执行步骤就是这样的，先查询当前日期，然后查询在当前年份下澳网男子冠军的名字。比如当前时间是2025年的话，就查询2025年的澳网男子冠军的名字。如果当前年份是2024年的话，那就查询2024年的澳网男子冠军的名字。查出名字后，我们再根据这个名字来查询这个冠军的家乡。没错，这就是一个非常合理的执行步骤。那计划有了之后，A镇的主程序便会把这个计划传给执行agent，让他去执行。这个计划中的第一步，也就是查询当前日期的那个步骤。这个执行agent可以用我们之前讲的react模式来运行，它内置一个网络搜索工具，这样呢它就可以通过搜索网络来查询当前日期了。当然执行agent也完全可以用别的模式来运行，plan execute模式呢只要求执行agent能够完成指定的步骤就行。至于它的运行模式是不是react内置工具有哪些，他完全不关心。执行agent内部一顿操作之后，就突出了一个执行结果，并返回了回去。然后agent的主程序会把用户问题、执行计划和执行记录都发给re模型，让他生成一个新的执行计划。毕竟我们拿到了第一步的执行结果了嘛，多了一些信息，情况呢可能会发生些变化。把原计划改改是再正常不过的事情了。那A镇的主程序接到新的执行计划之后，他便会回头再重复这个框中的流程。在我们这个例子中，这个框中的流程一共会运行三轮，对应了执行计划里面的三步。每一轮都包含两个环节，一个是执行环节，一个是reply环节。为了能够让你彻底明白，我们模拟一下这个循环中的三轮，让你看看每一轮的执行环节和re环节都具体发生了一些什么事情。在模拟开始前我先打个预防针，为了节省时间，我在模拟时讲解的速度会稍微快一些，如果你听不懂，建议在合适的时候稍微停一下。好，让我们开始。首先是第一轮，在执行阶段，我们把执行计划发给执行agent，让他处理其中的第一步。执行agent的返回之后，我们把它给出的执行结果加入到历史执行记录里。然后把用户问题第一个执行计划和历史执行记录一起发给reply模型，让他给出第二个执行计划。第一个执行计划和第二个执行计划有两点不同，这里我专门说一下。首先原来查询当前日期的那一步就不用出现在第二个执行计划里面了，毕竟已经执行完了，不用再执行了。另外查询澳网男子冠军名字的这一步呢也发生了一些变化，在第一个执行计划中，他叫做查询对应日期的澳网男子冠军名字，在第二个执行计划中，他叫做查询2025年的澳网男子冠军名字，毕竟日期已经查出来了，因此我们可以直接把具体的年份放到执行计划里，这样执行agent接到的任务就更加精确了。然后进入到第二轮，在这一轮中我们同样先取出最新的执行计划发给执行agent，让他执行其中的第一步。拿到执行结果后，我们再把执行结果加入到历史执行记录中。然后在replan阶段把用户问题执行计划和历史执行记录发给replan模型，拿到第三个执行计划。在第三轮中我们还是先取出执行计划，让执行agent处理其中的第一步。当然现在也只剩一步了，执行之后我们就可以拿到一个执行结果，把执行结果加入到历史执行记录里，然后再把用户问题执行记划和历史执行记录都发给re模型，让他再生成一个诶，好像所有的任务都已经完成了，没有步骤要做了吧。没错，在最后一轮中，replan模型会发现所有的步骤都已经做完了，用户的问题可以回答出来了。此时re模型返回的就不是最新的执行计划了，而是最终的答案。所以在流程图里面，我们要把执行计划换成最终答案。A镇的主程序接到这个最终答案之后，便会把这个答案转发给用户，整个流程也就结束了。所以回头看一下这个流程图，我们之前说A件的主程序请求re模型给出一个新的执行计划，这个说法呢其实并不准确。更准确的说法是agent的主程序请求re模型给出一个新的执行计划，或者是返回最终答案。如果还有步骤要执行的话呢，那就给出一个新的计划。如果没有步骤要做了，用户的问题已经回答出来了，那re模型就返回最终答案就好了。因此re模型的返回呢也有两种可能性，新的执行计划或者是最终答案。这样呢才是一个准确的流程图。相信到这里为止，你对plan excuse流程就有一个非常清晰的认识了。不过有些人可能想要plan exc的具体实间代码郎讯官方提供了一份，你可以到这个页面里面自行获取。今天的视频呢就到此结束了，别忘了点赞关注我们，下期再见，拜拜。",
  "title": "",
  "author": "",
  "publish_date": "",
  "source": "Bilibili (via SnapAny + Paraformer)",
  "language": "zh-CN",
  "word_count": 10225,
  "extraction_method": "snapany_paraformer",
  "extraction_timestamp": "2025-11-15T18:50:12.106735",
  "batch_id": "20251115_104313",
  "link_id": "bili_req15",
  "error": null
}