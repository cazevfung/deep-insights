{
  "success": true,
  "url": "https://read.engineerscodex.com/p/how-cursor-indexes-codebases-fast",
  "content": "How Cursor Indexes Codebases Fast\nMerkle Trees in the real world\nEngineer’s Codex is a publication about real-world software engineering.\nCursor, the popular AI IDE that recently announced they hit $300M ARR, uses Merkle trees to index code fast. This post goes over exactly how.\nBefore diving into Cursor's implementation, let's first understand what a Merkle tree is.\nMerkle Trees Explained Simply\nA Merkle tree is a tree structure in which every \"leaf\" node is labeled with the cryptographic hash of a data block, and every non-leaf node is labeled with the cryptographic hash of the labels of its child nodes. This creates a hierarchical structure where changes at any level can be efficiently detected by comparing hash values.\nThink of them as a fingerprinting system for data:\nEach piece of data (like a file) gets its own unique fingerprint (hash)\nPairs of fingerprints are combined and given a new fingerprint\nThis process continues until you have just one master fingerprint (the root hash)\nThe root hash summarizes all data contained in the individual pieces, serving as a cryptographic commitment to the entire dataset. The beauty of this approach is that if any single piece of data changes, it will change all the fingerprints above it, ultimately changing the root hash.\nSWE Quiz (Sponsored)\nTop software engineers know a lot. But how do you know what you don’t know?\nSWE Quiz is a platform with roadmaps on system design fundamentals, like API design, databases, and more. There are three roadmaps launching in June: distributed systems, LLM fundamentals, and a React interview roadmap.\nGet lifetime access to SWE Quiz, used by devs who have used the platform to get into companies like Google, Meta, and Airbnb.\nHow Cursor Uses Merkle Trees for Codebase Indexing\nCursor uses Merkle trees as a core component of its codebase indexing feature. According to a post by Cursor's founder and the security documentation, here's how it works:\nStep 1: Code Chunking and Processing\nCursor first chunks your codebase files locally, splitting code into semantically meaningful pieces before any processing occurs.\nStep 2: Merkle Tree Construction and Synchronization\nWhen codebase indexing is enabled, Cursor scans the folder opened in the editor and computes a Merkle tree of hashes of all valid files. This Merkle tree is then synchronized with Cursor's server, as detailed in Cursor's security documentation.\nStep 3: Embedding Generation\nAfter the chunks are sent to Cursor's server, embeddings are created using either OpenAI's embedding API or a custom embedding model (I couldn’t verify this). These vector representations capture the semantic meaning of the code chunks.\nStep 4: Storage and Indexing\nThe embeddings, along with metadata like start/end line numbers and file paths, are stored in a remote vector database (Turbopuffer). To maintain privacy while still enabling path-based filtering, Cursor stores an obfuscated relative file path with each vector. Importantly, according to Cursor's founder, \"None of your code is stored in our databases. It's gone after the life of the request.\"\nStep 5: Periodic Updates Using Merkle Trees\nEvery 10 minutes, Cursor checks for hash mismatches, using the Merkle tree to identify which files have changed. Only the changed files need to be uploaded, significantly reducing bandwidth usage, as explained in Cursor's security documentation. This is where the Merkle tree structure provides its greatest value—enabling efficient incremental updates.\nCode Chunking Strategies\nThe effectiveness of the codebase indexing largely depends on how code is chunked. While my previous explanation didn't go into detail about chunking methods, this blog post about building a Cursor-like codebase feature provides some insights:\nWhile simple approaches split code by characters, words, or lines, they often miss semantic boundaries—resulting in degraded embedding quality.\nYou can split code based on a fixed token count, but this can cut off code blocks like functions or classes mid-way.\nA more effective approach is to use an intelligent splitter that understands code structure, such as recursive text splitters that use high-level delimiters (e.g., class and function definitions) to split at appropriate semantic boundaries.\nAn even more elegant solution is to split the code based on its Abstract Syntax Tree (AST) structure. By traversing the AST depth-first, it splits code into sub-trees that fit within token limits. To avoid creating too many small chunks, sibling nodes are merged into larger chunks as long as they stay under the token limit. Tools like tree-sitter can be used for this AST parsing, supporting a wide range of programming languages.\nFor a crash course on tokens, read this.\nHow Embeddings Are Used at Inference Time\nAfter covering how Cursor creates and stores code embeddings, a natural question arises: how are these embeddings actually used once they've been generated? This section explains the practical application of these embeddings during normal usage.\nSemantic Search and Context Retrieval\nWhen you interact with Cursor's AI features like asking questions about your codebase (using @Codebase or ⌘ Enter), the following process occurs:\nQuery Embedding: Cursor computes an embedding for your question or the code context you're working with.\nVector Similarity Search: This query embedding is sent to Turbopuffer (Cursor's vector database), which performs a nearest-neighbor search to find code chunks semantically similar to your query.\nLocal File Access: Cursor's client receives the results, which include obfuscated file paths and line ranges of the most relevant code chunks. Importantly, the actual code content remains on your machine and is retrieved locally.\nContext Assembly: The client reads these relevant code chunks from your local files and sends them as context to the server for the LLM to process alongside your question.\nInformed Response: The LLM now has the necessary context from your codebase to provide a more informed and relevant response to your question or to generate appropriate code completions.\nThis embedding-powered retrieval allows for:\nContextual Code Generation: When writing new code, Cursor can reference similar implementations in your existing codebase, maintaining consistent patterns and styles.\nCodebase Q&A: You can ask questions about your codebase and get answers informed by your actual code rather than generic responses.\nSmart Code Completion: Code completions can be enhanced with awareness of your project's specific conventions and patterns.\nIntelligent Refactoring: When refactoring code, the system can identify all related pieces across your codebase that might need similar changes.\nWhy Cursor Uses Merkle Trees\nMany of these details are security-related, and thus can be found in Cursor’s security documentation.\n1. Efficient Incremental Updates\nBy using a Merkle tree, Cursor can quickly identify exactly which files have changed since the last synchronization. Instead of re-uploading the entire codebase, it only needs to upload the specific files that have been modified. This is important for large codebases where re-indexing everything would be too expensive in terms of bandwidth and processing time.\n2. Data Integrity Verification\nThe Merkle tree structure allows Cursor to efficiently verify that the files being indexed match what's stored on the server. The hierarchical hash structure makes it easy to detect any inconsistencies or corrupted data during transfer.\n3. Optimized Caching\nCursor stores embeddings in a cache indexed by the hash of the chunk, ensuring that indexing the same codebase a second time is much faster. This is great for teams where multiple developers might be working with the same codebase.\n4. Privacy-Preserving Indexing\nTo protect sensitive information in file paths, Cursor implements path obfuscation by splitting the path by '/' and '.' characters and encrypting each segment with a secret key stored on the client. While this still reveals some information about directory hierarchy, it hides most sensitive details.\n5. Git History Integration\nWhen codebase indexing is enabled in a Git repository, Cursor also indexes the Git history. It stores commit SHAs, parent information, and obfuscated file names. To enable sharing the data structure for users in the same Git repo and on the same team, the secret key for obfuscating file names is derived from hashes of recent commit contents.\nEmbedding Models and Considerations\nThe choice of embedding model significantly impacts the quality of code search and understanding. While some systems use open-source models like all-MiniLM-L6-v2, Cursor likely uses either OpenAI's embedding models or custom embedding models specifically tuned for code. For specialized code embeddings, models like Microsoft's unixcoder-base or Voyage AI's voyage-code-2 are good for code-specific semantic understanding.\nThe embedding challenge is made more complex because embedding models have token limits. OpenAI's text-embedding-3-small model, for example, has a token limit of 8192. Effective chunking helps stay within token limits while preserving semantic meaning.\nThe Handshake Process\nA key aspect of Cursor's Merkle tree implementation is the handshake process that occurs during synchronization. Logs from the Cursor application reveal that when initializing codebase indexing, Cursor creates a \"merkle client\" and performs a \"startup handshake\" with the server. This handshake involves sending the root hash of the locally computed Merkle tree to the server, as seen in Issue #2209 on GitHub and Issue #981 on GitHub.\nThe handshake process allows the server to determine which parts of the codebase need to be synced. Based on the handshake logs, we can see that Cursor computes the initial hash of the codebase and sends it to the server for verification, as documented in Issue #2209 on GitHub.\nTechnical Implementation Challenges\nWhile the Merkle tree approach offers many advantages, it's not without implementation challenges. Cursor's indexing feature often experiences heavy load, causing many requests to fail. This can result in files needing to be uploaded several times before they get fully indexed. Users might notice higher than expected network traffic to 'repo42.cursor.sh' as a result of these retry mechanisms, as mentioned in Cursor's security documentation.\nAnother challenge relates to embedding security. Academic research has shown that reversing embeddings is possible in some cases. While current attacks typically rely on having access to the embedding model and working with short strings, there is a potential risk that an adversary who gains access to Cursor's vector database could extract information about indexed codebases from the stored embeddings.",
  "title": "",
  "author": "",
  "publish_date": "",
  "source": "read.engineerscodex.com",
  "language": "auto",
  "word_count": 1651,
  "extraction_method": "article_trafilatura",
  "extraction_timestamp": "2025-11-05T23:12:06.626248",
  "batch_id": "20251105_151201",
  "link_id": "art_req2",
  "error": null,
  "article_id": "7c9858df1981",
  "summary": {
    "transcript_summary": {
      "key_facts": [
        "FACT: Cursor uses Merkle trees to efficiently index codebases by creating a hierarchical hash structure of code files.",
        "FACT: Code is split into semantically meaningful chunks before being processed for indexing in Cursor.",
        "FACT: Cursor computes a Merkle tree of file hashes locally and synchronizes the root hash with its server.",
        "FACT: Embeddings are generated from code chunks using either OpenAI's API or a custom embedding model.",
        "FACT: Vector embeddings are stored in Turbopuffer, a remote vector database, with obfuscated file paths for privacy.",
        "FACT: Cursor does not store actual code content in its databases; data is discarded after the request lifecycle.",
        "FACT: Every 10 minutes, Cursor checks for hash mismatches using the Merkle tree to detect changed files.",
        "FACT: Only modified files are re-uploaded during incremental updates, reducing bandwidth usage significantly.",
        "FACT: Intelligent code chunking based on AST structure improves embedding quality by preserving semantic boundaries.",
        "FACT: Tree-sitter is used for AST parsing across multiple programming languages to support structured splitting.",
        "FACT: During AI interactions, query embeddings are matched against stored code embeddings via nearest-neighbor search.",
        "FACT: Relevant code chunks are retrieved from local files using obfuscated paths and sent as context to the LLM.",
        "FACT: The handshake process involves sending the root Merkle hash from client to server to initiate synchronization.",
        "FACT: Git history is indexed when enabled, including commit SHAs, parent information, and obfuscated file names.",
        "FACT: The secret key for path obfuscation is derived from recent commit contents in shared team environments."
      ],
      "key_opinions": [
        "OPINION: The Merkle tree approach enables scalable and secure codebase indexing without compromising performance.",
        "OPINION: Intelligent chunking based on AST structure is superior to simple line-based or token-based splitting.",
        "OPINION: Embedding models tuned for code produce more accurate and contextually relevant results than general-purpose models.",
        "OPINION: Path obfuscation strikes a balance between privacy and usability by hiding sensitive directory names.",
        "OPINION: The handshake mechanism ensures trust and consistency between client and server during initial sync.",
        "OPINION: Incremental updates via Merkle trees are essential for large codebases to avoid excessive network overhead.",
        "OPINION: Despite security benefits, embedding reversibility poses a theoretical risk if vector data is compromised.",
        "OPINION: The reliance on third-party APIs like OpenAI introduces potential dependency risks for core functionality.",
        "OPINION: High retry rates during indexing suggest implementation challenges that affect user experience.",
        "OPINION: Team-based obfuscation keys derived from Git history enhance collaboration while maintaining privacy."
      ],
      "key_datapoints": [
        "DATA: Cursor achieved $300M ARR, indicating strong commercial traction in the AI IDE market.",
        "DATA: Merkle tree updates occur every 10 minutes to detect file changes efficiently.",
        "DATA: OpenAI's text-embedding-3-small model has a token limit of 8192 per input.",
        "DATA: Embeddings are cached using chunk hash keys, enabling faster re-indexing of identical codebases.",
        "DATA: File paths are obfuscated by splitting on '/' and '.' and encrypting each segment with a client-side key.",
        "DATA: Vector similarity searches are performed in Turbopuffer, Cursor’s remote vector database.",
        "DATA: Codebase indexing fails frequently under heavy load, leading to repeated upload attempts.",
        "DATA: Network traffic to 'repo42.cursor.sh' increases due to retry mechanisms during indexing.",
        "DATA: Commit SHAs, parent commits, and obfuscated file names are stored when Git history is indexed.",
        "DATA: Secret keys for path obfuscation are derived from hashes of recent commit contents in shared repos.",
        "DATA: AST-based chunking merges sibling nodes into larger chunks as long as token limits are respected.",
        "DATA: Cursor’s security documentation confirms no code is stored beyond the life of a request.",
        "DATA: The Merkle tree root hash is sent during the startup handshake to verify codebase state.",
        "DATA: Tree-sitter supports parsing for a wide range of programming languages in AST-based chunking.",
        "DATA: Custom embedding models may be used alongside OpenAI’s API to improve code-specific understanding."
      ],
      "topic_areas": [
        "Merkle tree implementation",
        "Codebase indexing",
        "Vector embeddings",
        "Incremental updates",
        "Privacy-preserving design",
        "AST-based chunking",
        "Semantic search",
        "Git integration",
        "Embedding security",
        "AI IDE architecture"
      ],
      "word_count": 1651,
      "total_markers": 40
    },
    "comments_summary": {},
    "created_at": "2025-11-05T23:13:46.386370",
    "model_used": "qwen-flash"
  }
}