{
  "success": true,
  "url": "https://redis.io/docs/latest/develop/ai/search-and-query/indexing/",
  "content": "Indexing\nHow to index and search JSON documents\nIn addition to indexing Redis hashes, Redis Open Source can also index JSON documents.\nCreate index with JSON schema\nWhen you create an index with the FT.CREATE\ncommand, include the ON JSON\nkeyword to index any existing and future JSON documents stored in the database.\nTo define the SCHEMA\n, you can provide JSONPath expressions.\nThe result of each JSONPath expression is indexed and associated with a logical name called an attribute\n(previously known as a field\n).\nYou can use these attributes in queries.\nUse the following syntax to create a JSON index:\nFT.CREATE {index_name} ON JSON SCHEMA {json_path} AS {attribute} {type}\nFor example, this command creates an index that indexes the name, description, price, and image vector embedding of each JSON document that represents an inventory item:\n127.0.0.1:6379> FT.CREATE itemIdx ON JSON PREFIX 1 item: SCHEMA $.name AS name TEXT $.description as description TEXT $.price AS price NUMERIC $.embedding AS embedding VECTOR FLAT 6 DIM 4 DISTANCE_METRIC L2 TYPE FLOAT32\nSee Index limitations for more details about JSON index SCHEMA\nrestrictions.\nAdd JSON documents\nAfter you create an index, Redis automatically indexes any existing, modified, or newly created JSON documents stored in the database. For existing documents, indexing runs asynchronously in the background, so it can take some time before the document is available. Modified and newly created documents are indexed synchronously, so the document will be available by the time the add or modify command finishes.\nYou can use any JSON write command, such as JSON.SET\nand JSON.ARRAPPEND\n, to create or modify JSON documents.\nThe following examples use these JSON documents to represent individual inventory items.\nItem 1 JSON document:\n{\n\"name\": \"Noise-cancelling Bluetooth headphones\",\n\"description\": \"Wireless Bluetooth headphones with noise-cancelling technology\",\n\"connection\": {\n\"wireless\": true,\n\"type\": \"Bluetooth\"\n},\n\"price\": 99.98,\n\"stock\": 25,\n\"colors\": [\n\"black\",\n\"silver\"\n],\n\"embedding\": [0.87, -0.15, 0.55, 0.03]\n}\nItem 2 JSON document:\n{\n\"name\": \"Wireless earbuds\",\n\"description\": \"Wireless Bluetooth in-ear headphones\",\n\"connection\": {\n\"wireless\": true,\n\"type\": \"Bluetooth\"\n},\n\"price\": 64.99,\n\"stock\": 17,\n\"colors\": [\n\"black\",\n\"white\"\n],\n\"embedding\": [-0.7, -0.51, 0.88, 0.14]\n}\nUse JSON.SET\nto store these documents in the database:\n127.0.0.1:6379> JSON.SET item:1 $ '{\"name\":\"Noise-cancelling Bluetooth headphones\",\"description\":\"Wireless Bluetooth headphones with noise-cancelling technology\",\"connection\":{\"wireless\":true,\"type\":\"Bluetooth\"},\"price\":99.98,\"stock\":25,\"colors\":[\"black\",\"silver\"],\"embedding\":[0.87,-0.15,0.55,0.03]}'\n\"OK\"\n127.0.0.1:6379> JSON.SET item:2 $ '{\"name\":\"Wireless earbuds\",\"description\":\"Wireless Bluetooth in-ear headphones\",\"connection\":{\"wireless\":true,\"type\":\"Bluetooth\"},\"price\":64.99,\"stock\":17,\"colors\":[\"black\",\"white\"],\"embedding\":[-0.7,-0.51,0.88,0.14]}'\n\"OK\"\nBecause indexing is synchronous in this case, the documents will be available on the index as soon as the JSON.SET\ncommand returns.\nAny subsequent queries that match the indexed content will return the document.\nSearch the index\nTo search the index for JSON documents, use the FT.SEARCH\ncommand.\nYou can search any attribute defined in the SCHEMA\n.\nFor example, use this query to search for items with the word \"earbuds\" in the name:\n127.0.0.1:6379> FT.SEARCH itemIdx '@name:(earbuds)'\n1) \"1\"\n2) \"item:2\"\n3) 1) \"$\"\n2) \"{\\\"name\\\":\\\"Wireless earbuds\\\",\\\"description\\\":\\\"Wireless Bluetooth in-ear headphones\\\",\\\"connection\\\":{\\\"wireless\\\":true,\\\"connection\\\":\\\"Bluetooth\\\"},\\\"price\\\":64.99,\\\"stock\\\":17,\\\"colors\\\":[\\\"black\\\",\\\"white\\\"],\\\"embedding\\\":[-0.7,-0.51,0.88,0.14]}\"\nThis query searches for all items that include \"bluetooth\" and \"headphones\" in the description:\n127.0.0.1:6379> FT.SEARCH itemIdx '@description:(bluetooth headphones)'\n1) \"2\"\n2) \"item:1\"\n3) 1) \"$\"\n2) \"{\\\"name\\\":\\\"Noise-cancelling Bluetooth headphones\\\",\\\"description\\\":\\\"Wireless Bluetooth headphones with noise-cancelling technology\\\",\\\"connection\\\":{\\\"wireless\\\":true,\\\"type\\\":\\\"Bluetooth\\\"},\\\"price\\\":99.98,\\\"stock\\\":25,\\\"colors\\\":[\\\"black\\\",\\\"silver\\\"], \\\"embedding\\\":[0.87,-0.15,0.55,0.03]}\"\n4) \"item:2\"\n5) 1) \"$\"\n2) \"{\\\"name\\\":\\\"Wireless earbuds\\\",\\\"description\\\":\\\"Wireless Bluetooth in-ear headphones\\\",\\\"connection\\\":{\\\"wireless\\\":true,\\\"connection\\\":\\\"Bluetooth\\\"},\\\"price\\\":64.99,\\\"stock\\\":17,\\\"colors\\\":[\\\"black\\\",\\\"white\\\"],\\\"embedding\\\":[-0.7,-0.51,0.88,0.14]}\"\nNow search for Bluetooth headphones with a price less than 70:\n127.0.0.1:6379> FT.SEARCH itemIdx '@description:(bluetooth headphones) @price:[0 70]'\n1) \"1\"\n2) \"item:2\"\n3) 1) \"$\"\n2) \"{\\\"name\\\":\\\"Wireless earbuds\\\",\\\"description\\\":\\\"Wireless Bluetooth in-ear headphones\\\",\\\"connection\\\":{\\\"wireless\\\":true,\\\"connection\\\":\\\"Bluetooth\\\"},\\\"price\\\":64.99,\\\"stock\\\":17,\\\"colors\\\":[\\\"black\\\",\\\"white\\\"],\\\"embedding\\\":[-0.7,-0.51,0.88,0.14]}\"\nAnd lastly, search for the Bluetooth headphones that are most similar to an image whose embedding is [1.0, 1.0, 1.0, 1.0]:\n127.0.0.1:6379> FT.SEARCH itemIdx '@description:(bluetooth headphones)=>[KNN 2 @embedding $blob]' PARAMS 2 blob \\x01\\x01\\x01\\x01 DIALECT 2\n1) \"2\"\n2) \"item:1\"\n3) 1) \"__embedding_score\"\n2) \"1.08280003071\"\n1) \"$\"\n2) \"{\\\"name\\\":\\\"Noise-cancelling Bluetooth headphones\\\",\\\"description\\\":\\\"Wireless Bluetooth headphones with noise-cancelling technology\\\",\\\"connection\\\":{\\\"wireless\\\":true,\\\"type\\\":\\\"Bluetooth\\\"},\\\"price\\\":99.98,\\\"stock\\\":25,\\\"colors\\\":[\\\"black\\\",\\\"silver\\\"],\\\"embedding\\\":[0.87,-0.15,0.55,0.03]}\"\n2) \"item:2\"\n3) 1) \"__embedding_score\"\n2) \"1.54409992695\"\n3) \"$\"\n4) \"{\\\"name\\\":\\\"Wireless earbuds\\\",\\\"description\\\":\\\"Wireless Bluetooth in-ear headphones\\\",\\\"connection\\\":{\\\"wireless\\\":true,\\\"connection\\\":\\\"Bluetooth\\\"},\\\"price\\\":64.99,\\\"stock\\\":17,\\\"colors\\\":[\\\"black\\\",\\\"white\\\"],\\\"embedding\\\":[-0.7,-0.51,0.88,0.14]}\"\nFor more information about search queries, see Search query syntax.\nFT.SEARCH\nqueries require attribute\nmodifiers. Don't use JSONPath expressions in queries because the query parser doesn't fully support them.Understanding TAG field behavior: hash versus JSON\nTAG fields behave differently depending on whether you're indexing hash or JSON documents. This difference is a common source of confusion.\nHash documents\n# HASH: Comma is the default separator\nHSET product:1 category \"Electronics,Gaming,PC\"\nFT.CREATE products ON HASH PREFIX 1 product: SCHEMA category TAG\n# Result: Creates 3 separate tags: \"Electronics\", \"Gaming\", \"PC\"\nFT.SEARCH products '@category:{Gaming}' # ✅ Finds the document\nJSON documents\n# JSON: No default separator - the entire string becomes one tag\nJSON.SET product:1 $ '{\"category\": \"Electronics,Gaming,PC\"}'\nFT.CREATE products ON JSON PREFIX 1 product: SCHEMA $.category AS category TAG\n# Result: Creates 1 tag: \"Electronics,Gaming,PC\"\nFT.SEARCH products '@category:{Gaming}' # ❌ Does NOT find the document\nFT.SEARCH products '@category:{Electronics,Gaming,PC}' # ✅ Finds the document\nMaking JSON documents behave like hash documents\nTo get hash-like behavior in JSON, explicitly add SEPARATOR \",\"\n:\nJSON.SET product:1 $ '{\"category\": \"Electronics,Gaming,PC\"}'\nFT.CREATE products ON JSON PREFIX 1 product: SCHEMA $.category AS category TAG SEPARATOR \",\"\n# Result: Creates 3 separate tags: \"Electronics\", \"Gaming\", \"PC\"\nFT.SEARCH products '@category:{Gaming}' # ✅ Now finds the document\nRecommended approach for JSON\nInstead of comma-separated strings, use JSON arrays:\nJSON.SET product:1 $ '{\"category\": [\"Electronics\", \"Gaming\", \"PC\"]}'\nFT.CREATE products ON JSON PREFIX 1 product: SCHEMA $.category[*] AS category TAG\n# Result: Creates 3 separate tags: \"Electronics\", \"Gaming\", \"PC\"\nFT.SEARCH products '@category:{Gaming}' # ✅ Finds the document\nIndex JSON arrays as TAG\nFor JSON documents, you have two approaches to create TAG fields with multiple values:\nApproach 1: JSON arrays (recommended)\nThe preferred method for indexing multiple tag values is using JSON arrays. Each array element becomes a separate tag value. Use the JSONPath wildcard operator [*]\nto index array elements.\n# Create index with array indexing\n127.0.0.1:6379> FT.CREATE itemIdx2 ON JSON PREFIX 1 item: SCHEMA $.colors[*] AS colors TAG $.name AS name TEXT $.description as description TEXT\n# The JSON data uses arrays\n# Each array element (\"black\", \"silver\") becomes a separate tag\nNow you can search for silver headphones:\n127.0.0.1:6379> FT.SEARCH itemIdx2 \"@colors:{silver} (@name:(headphones)|@description:(headphones))\"\n1) \"1\"\n2) \"item:1\"\n3) 1) \"$\"\n2) \"{\\\"name\\\":\\\"Noise-cancelling Bluetooth headphones\\\",\\\"description\\\":\\\"Wireless Bluetooth headphones with noise-cancelling technology\\\",\\\"connection\\\":{\\\"wireless\\\":true,\\\"type\\\":\\\"Bluetooth\\\"},\\\"price\\\":99.98,\\\"stock\\\":25,\\\"colors\\\":[\\\"black\\\",\\\"silver\\\"]}\"\nApproach 2: strings with explicit separators\nYou can also use comma-separated strings, but you must explicitly specify the SEPARATOR\n:\n# JSON with comma-separated string\nJSON.SET item:1 $ '{\"colors\": \"black,silver,gold\"}'\n# Index with explicit separator\nFT.CREATE itemIdx3 ON JSON PREFIX 1 item: SCHEMA $.colors AS colors TAG SEPARATOR \",\"\n# Now you can search individual colors\nFT.SEARCH itemIdx3 \"@colors:{silver}\"\n- JSON without SEPARATOR:\n\"black,silver\"\nbecomes one tag:\"black,silver\"\n. - JSON with SEPARATOR \",\":\n\"black,silver\"\nbecomes two tags:\"black\"\nand\"silver\"\n. - Hash (default):\n\"black,silver\"\nbecomes two tags:\"black\"\nand\"silver\"\n.\nFor JSON, always specify SEPARATOR \",\"\nif you want to split comma-separated strings, or use arrays instead.\nWhich approach to choose?\nUse JSON arrays when:\n- You control the data structure.\n- You want clean, structured data.\n- You need to store complex values (strings with spaces, punctuation).\nUse strings with separators when:\n- You're migrating from hashes to JSON.\n- You receive data as delimited strings.\n- You need compatibility with existing systems.\nIndex JSON arrays as TEXT\nStarting with RediSearch v2.6.0, full text search can be done on an array of strings or on a JSONPath leading to multiple strings.\nIf you want to index multiple string values as TEXT, use either a JSONPath leading to a single array of strings, or a JSONPath leading to multiple string values, using JSONPath operators such as wildcard, filter, union, array slice, and/or recursive descent.\nTo index an item's list of available colors, specify the JSONPath $.colors\nin the SCHEMA\ndefinition during index creation:\n127.0.0.1:6379> FT.CREATE itemIdx3 ON JSON PREFIX 1 item: SCHEMA $.colors AS colors TEXT $.name AS name TEXT $.description as description TEXT\n127.0.0.1:6379> JSON.SET item:3 $ '{\"name\":\"True Wireless earbuds\",\"description\":\"True Wireless Bluetooth in-ear headphones\",\"connection\":{\"wireless\":true,\"type\":\"Bluetooth\"},\"price\":74.99,\"stock\":20,\"colors\":[\"red\",\"light blue\"]}'\n\"OK\"\nNow you can do full text search for light colored headphones:\n127.0.0.1:6379> FT.SEARCH itemIdx3 '@colors:(white|light) (@name|description:(headphones))' RETURN 1 $.colors\n1) (integer) 2\n2) \"item:2\"\n3) 1) \"$.colors\"\n2) \"[\\\"black\\\",\\\"white\\\"]\"\n4) \"item:3\"\n5) 1) \"$.colors\"\n2) \"[\\\"red\\\",\\\"light blue\\\"]\"\nLimitations\n-\nWhen a JSONPath may lead to multiple values and not only to a single array, e.g., when a JSONPath contains wildcards, etc., specifying\nSLOP\norINORDER\ninFT.SEARCH\nwill return an error, since the order of the values matching the JSONPath is not well defined, leading to potentially inconsistent results.For example, using a JSONPath such as\n$..b[*]\non a JSON value such as{ \"a\": [ {\"b\": [\"first first\", \"first second\"]}, {\"c\": {\"b\": [\"second first\", \"second second\"]}}, {\"b\": [\"third first\", \"third second\"]} ] }\nmay match values in various orderings, depending on the specific implementation of the JSONPath library being used.\nSince\nSLOP\nandINORDER\nconsider relative ordering among the indexed values, and results may change in future releases, an error will be returned. -\nWhen JSONPath leads to multiple values:\n- String values are indexed\nnull\nvalues are skipped- Any other value type will cause an indexing failure\n-\nSORTBY\nonly sorts by the first value -\nNo\nHIGHLIGHT\nandSUMMARIZE\nsupport -\nRETURN\nof a Schema attribute, whose JSONPath leads to multiple values, returns only the first value (as a JSON String) -\nIf a JSONPath is specified by the\nRETURN\n, instead of a Schema attribute, all values are returned (as a JSON String)\nHandling phrases in different array slots:\nWhen indexing, a predefined delta is used to increase positional offsets between array slots for multiple text values. This delta controls the level of separation between phrases in different array slots (related to the SLOP\nparameter of FT.SEARCH\n).\nThis predefined value is set by the configuration parameter MULTI_TEXT_SLOP\n(at module load-time). The default value is 100.\nIndex JSON arrays as NUMERIC\nStarting with RediSearch v2.6.1, search can be done on an array of numerical values or on a JSONPath leading to multiple numerical values.\nIf you want to index multiple numerical values as NUMERIC, use either a JSONPath leading to a single array of numbers, or a JSONPath leading to multiple numbers, using JSONPath operators such as wildcard, filter, union, array slice, and/or recursive descent.\nFor example, add to the item's list the available max_level\nof volume (in decibels):\n127.0.0.1:6379> JSON.SET item:1 $ '{\"name\":\"Noise-cancelling Bluetooth headphones\",\"description\":\"Wireless Bluetooth headphones with noise-cancelling technology\",\"connection\":{\"wireless\":true,\"type\":\"Bluetooth\"},\"price\":99.98,\"stock\":25,\"colors\":[\"black\",\"silver\"], \"max_level\":[60, 70, 80, 90, 100]}'\nOK\n127.0.0.1:6379> JSON.SET item:2 $ '{\"name\":\"Wireless earbuds\",\"description\":\"Wireless Bluetooth in-ear headphones\",\"connection\":{\"wireless\":true,\"type\":\"Bluetooth\"},\"price\":64.99,\"stock\":17,\"colors\":[\"black\",\"white\"], \"max_level\":[80, 100, 120]}'\nOK\n127.0.0.1:6379> JSON.SET item:3 $ '{\"name\":\"True Wireless earbuds\",\"description\":\"True Wireless Bluetooth in-ear headphones\",\"connection\":{\"wireless\":true,\"type\":\"Bluetooth\"},\"price\":74.99,\"stock\":20,\"colors\":[\"red\",\"light blue\"], \"max_level\":[90, 100, 110, 120]}'\nOK\nTo index the max_level\narray, specify the JSONPath $.max_level\nin the SCHEMA\ndefinition during index creation:\n127.0.0.1:6379> FT.CREATE itemIdx4 ON JSON PREFIX 1 item: SCHEMA $.max_level AS dB NUMERIC\nOK\nYou can now search for headphones with specific max volume levels, for example, between 70 and 80 (inclusive), returning items with at least one value in their max_level\narray, which is in the requested range:\n127.0.0.1:6379> FT.SEARCH itemIdx4 '@dB:[70 80]'\n1) (integer) 2\n2) \"item:1\"\n3) 1) \"$\"\n2) \"{\\\"name\\\":\\\"Noise-cancelling Bluetooth headphones\\\",\\\"description\\\":\\\"Wireless Bluetooth headphones with noise-cancelling technology\\\",\\\"connection\\\":{\\\"wireless\\\":true,\\\"type\\\":\\\"Bluetooth\\\"},\\\"price\\\":99.98,\\\"stock\\\":25,\\\"colors\\\":[\\\"black\\\",\\\"silver\\\"],\\\"max_level\\\":[60,70,80,90,100]}\"\n4) \"item:2\"\n5) 1) \"$\"\n2) \"{\\\"name\\\":\\\"Wireless earbuds\\\",\\\"description\\\":\\\"Wireless Bluetooth in-ear headphones\\\",\\\"connection\\\":{\\\"wireless\\\":true,\\\"type\\\":\\\"Bluetooth\\\"},\\\"price\\\":64.99,\\\"stock\\\":17,\\\"colors\\\":[\\\"black\\\",\\\"white\\\"],\\\"max_level\\\":[80,100,120]}\"\nYou can also search for items with all values in a specific range. For example, all values are in the range [90, 120] (inclusive):\n127.0.0.1:6379> FT.SEARCH itemIdx4 '-@dB:[-inf (90] -@dB:[(120 +inf]'\n1) (integer) 1\n2) \"item:3\"\n3) 1) \"$\"\n2) \"{\\\"name\\\":\\\"True Wireless earbuds\\\",\\\"description\\\":\\\"True Wireless Bluetooth in-ear headphones\\\",\\\"connection\\\":{\\\"wireless\\\":true,\\\"type\\\":\\\"Bluetooth\\\"},\\\"price\\\":74.99,\\\"stock\\\":20,\\\"colors\\\":[\\\"red\\\",\\\"light blue\\\"],\\\"max_level\\\":[90,100,110,120]}\"\nLimitations\nWhen JSONPath leads to multiple numerical values:\n- Numerical values are indexed\nnull\nvalues are skipped- Any other value type will cause an indexing failure\nIndex JSON arrays as GEO and GEOSHAPE\nYou can use GEO\nand GEOSHAPE\nfields to store geospatial data,\nsuch as geographical locations and geometric shapes. See\nGeospatial indexing\nto learn how to use these schema types and see the\nGeospatial\nreference page for an introduction to their format and usage.\nIndex JSON arrays as VECTOR\nStarting with RediSearch 2.6.0, you can index a JSONPath leading to an array of numeric values as a VECTOR type in the index schema.\nFor example, assume that your JSON items include an array of vector embeddings, where each vector represents an image of a product. To index these vectors, specify the JSONPath $.embedding\nin the schema definition during index creation:\n127.0.0.1:6379> FT.CREATE itemIdx5 ON JSON PREFIX 1 item: SCHEMA $.embedding AS embedding VECTOR FLAT 6 DIM 4 DISTANCE_METRIC L2 TYPE FLOAT32\nOK\n127.0.0.1:6379> JSON.SET item:1 $ '{\"name\":\"Noise-cancelling Bluetooth headphones\",\"description\":\"Wireless Bluetooth headphones with noise-cancelling technology\",\"price\":99.98,\"stock\":25,\"colors\":[\"black\",\"silver\"],\"embedding\":[0.87,-0.15,0.55,0.03]}'\nOK\n127.0.0.1:6379> JSON.SET item:2 $ '{\"name\":\"Wireless earbuds\",\"description\":\"Wireless Bluetooth in-ear headphones\",\"price\":64.99,\"stock\":17,\"colors\":[\"black\",\"white\"],\"embedding\":[-0.7,-0.51,0.88,0.14]}'\nOK\nNow you can search for the two headphones that are most similar to the image embedding by using vector search KNN query. (Note that the vector queries are supported as of dialect 2.) For example:\n127.0.0.1:6379> FT.SEARCH itemIdx5 '*=>[KNN 2 @embedding $blob AS dist]' SORTBY dist PARAMS 2 blob \\x01\\x01\\x01\\x01 DIALECT 2\n1) (integer) 2\n2) \"item:1\"\n3) 1) \"dist\"\n2) \"1.08280003071\"\n3) \"$\"\n4) \"{\\\"name\\\":\\\"Noise-cancelling Bluetooth headphones\\\",\\\"description\\\":\\\"Wireless Bluetooth headphones with noise-cancelling technology\\\",\\\"price\\\":99.98,\\\"stock\\\":25,\\\"colors\\\":[\\\"black\\\",\\\"silver\\\"],\\\"embedding\\\":[0.87,-0.15,0.55,0.03]}\"\n4) \"item:2\"\n5) 1) \"dist\"\n2) \"1.54409992695\"\n3) \"$\"\n4) \"{\\\"name\\\":\\\"Wireless earbuds\\\",\\\"description\\\":\\\"Wireless Bluetooth in-ear headphones\\\",\\\"price\\\":64.99,\\\"stock\\\":17,\\\"colors\\\":[\\\"black\\\",\\\"white\\\"],\\\"embedding\\\":[-0.7,-0.51,0.88,0.14]}\"\nIf you want to index multiple numeric arrays as VECTOR, use a JSONPath leading to multiple numeric arrays using JSONPath operators such as wildcard, filter, union, array slice, and/or recursive descent.\nFor example, assume that your JSON items include an array of vector embeddings, where each vector represents a different image of the same product. To index these vectors, specify the JSONPath $.embeddings[*]\nin the schema definition during index creation:\n127.0.0.1:6379> FT.CREATE itemIdx5 ON JSON PREFIX 1 item: SCHEMA $.embeddings[*] AS embeddings VECTOR FLAT 6 DIM 4 DISTANCE_METRIC L2 TYPE FLOAT32\nOK\n127.0.0.1:6379> JSON.SET item:1 $ '{\"name\":\"Noise-cancelling Bluetooth headphones\",\"description\":\"Wireless Bluetooth headphones with noise-cancelling technology\",\"price\":99.98,\"stock\":25,\"colors\":[\"black\",\"silver\"],\"embeddings\":[[0.87,-0.15,0.55,0.03]]}'\nOK\n127.0.0.1:6379> JSON.SET item:2 $ '{\"name\":\"Wireless earbuds\",\"description\":\"Wireless Bluetooth in-ear headphones\",\"price\":64.99,\"stock\":17,\"colors\":[\"black\",\"white\"],\"embeddings\":[[-0.7,-0.51,0.88,0.14],[-0.8,-0.15,0.33,-0.01]]}'\nOK\n$.embedding\nin the schema for the VECTOR type does not allow you to index multiple vectors stored under that field. Hence, if you set $.embedding\nas the path to the index schema, specifying an array of vectors in the embedding\nfield in your JSON will cause an indexing failure.Now you can search for the two headphones that are most similar to an image embedding by using vector search KNN query. (Note that the vector queries are supported as of dialect 2.) The distance between a document to the query vector is defined as the minimum distance between the query vector to a vector that matches the JSONPath specified in the schema. For example:\n127.0.0.1:6379> FT.SEARCH itemIdx5 '*=>[KNN 2 @embeddings $blob AS dist]' SORTBY dist PARAMS 2 blob \\x01\\x01\\x01\\x01 DIALECT 2\n1) (integer) 2\n2) \"item:2\"\n3) 1) \"dist\"\n2) \"0.771500051022\"\n3) \"$\"\n4) \"{\\\"name\\\":\\\"Wireless earbuds\\\",\\\"description\\\":\\\"Wireless Bluetooth in-ear headphones\\\",\\\"price\\\":64.99,\\\"stock\\\":17,\\\"colors\\\":[\\\"black\\\",\\\"white\\\"],\\\"embeddings\\\":[[-0.7,-0.51,0.88,0.14],[-0.8,-0.15,0.33,-0.01]]}\"\n4) \"item:1\"\n5) 1) \"dist\"\n2) \"1.08280003071\"\n3) \"$\"\n4) \"{\\\"name\\\":\\\"Noise-cancelling Bluetooth headphones\\\",\\\"description\\\":\\\"Wireless Bluetooth headphones with noise-cancelling technology\\\",\\\"price\\\":99.98,\\\"stock\\\":25,\\\"colors\\\":[\\\"black\\\",\\\"silver\\\"],\\\"embeddings\\\":[[0.87,-0.15,0.55,0.03]]}\"\nNote that 0.771500051022\nis the L2 distance between the query vector and [-0.8,-0.15,0.33,-0.01]\n, which is the second element in the embedding array, and it is lower than the L2 distance between the query vector and [-0.7,-0.51,0.88,0.14]\n, which is the first element in the embedding array.\nFor more information on vector similarity syntax, see Vector fields.\nIndex JSON objects\nYou cannot index JSON objects. FT.CREATE will return an error if the JSONPath expression returns an object.\nTo index the contents of a JSON object, you need to index the individual elements within the object in separate attributes.\nFor example, to index the connection\nJSON object, define the $.connection.wireless\nand $.connection.type\nfields as separate attributes when you create the index:\n127.0.0.1:6379> FT.CREATE itemIdx3 ON JSON SCHEMA $.connection.wireless AS wireless TAG $.connection.type AS connectionType TEXT\n\"OK\"\nAfter you create the new index, you can search for items with the wireless TAG set to true\n:\n127.0.0.1:6379> FT.SEARCH itemIdx3 '@wireless:{true}'\n1) \"2\"\n2) \"item:2\"\n3) 1) \"$\"\n2) \"{\\\"name\\\":\\\"Wireless earbuds\\\",\\\"description\\\":\\\"Wireless Bluetooth in-ear headphones\\\",\\\"connection\\\":{\\\"wireless\\\":true,\\\"connection\\\":\\\"Bluetooth\\\"},\\\"price\\\":64.99,\\\"stock\\\":17,\\\"colors\\\":[\\\"black\\\",\\\"white\\\"]}\"\n4) \"item:1\"\n5) 1) \"$\"\n2) \"{\\\"name\\\":\\\"Noise-cancelling Bluetooth headphones\\\",\\\"description\\\":\\\"Wireless Bluetooth headphones with noise-cancelling technology\\\",\\\"connection\\\":{\\\"wireless\\\":true,\\\"type\\\":\\\"Bluetooth\\\"},\\\"price\\\":99.98,\\\"stock\\\":25,\\\"colors\\\":[\\\"black\\\",\\\"silver\\\"]}\"\nYou can also search for items with a Bluetooth connection type:\n127.0.0.1:6379> FT.SEARCH itemIdx3 '@connectionType:(bluetooth)'\n1) \"2\"\n2) \"item:1\"\n3) 1) \"$\"\n2) \"{\\\"name\\\":\\\"Noise-cancelling Bluetooth headphones\\\",\\\"description\\\":\\\"Wireless Bluetooth headphones with noise-cancelling technology\\\",\\\"connection\\\":{\\\"wireless\\\":true,\\\"type\\\":\\\"Bluetooth\\\"},\\\"price\\\":99.98,\\\"stock\\\":25,\\\"colors\\\":[\\\"black\\\",\\\"silver\\\"]}\"\n4) \"item:2\"\n5) 1) \"$\"\n2) \"{\\\"name\\\":\\\"Wireless earbuds\\\",\\\"description\\\":\\\"Wireless Bluetooth in-ear headphones\\\",\\\"connection\\\":{\\\"wireless\\\":true,\\\"type\\\":\\\"Bluetooth\\\"},\\\"price\\\":64.99,\\\"stock\\\":17,\\\"colors\\\":[\\\"black\\\",\\\"white\\\"]}\"\nField projection\nFT.SEARCH\nreturns the entire JSON document by default. If you want to limit the returned search results to specific attributes, you can use field projection.\nReturn specific attributes\nWhen you run a search query, you can use the RETURN\nkeyword to specify which attributes you want to include in the search results. You also need to specify the number of fields to return.\nFor example, this query only returns the name\nand price\nof each set of headphones:\n127.0.0.1:6379> FT.SEARCH itemIdx '@description:(headphones)' RETURN 2 name price\n1) \"2\"\n2) \"item:1\"\n3) 1) \"name\"\n2) \"Noise-cancelling Bluetooth headphones\"\n3) \"price\"\n4) \"99.98\"\n4) \"item:2\"\n5) 1) \"name\"\n2) \"Wireless earbuds\"\n3) \"price\"\n4) \"64.99\"\nProject with JSONPath\nYou can use JSONPath expressions in a RETURN\nstatement to extract any part of the JSON document, even fields that were not defined in the index SCHEMA\n.\nFor example, the following query uses the JSONPath expression $.stock\nto return each item's stock in addition to the name and price attributes.\n127.0.0.1:6379> FT.SEARCH itemIdx '@description:(headphones)' RETURN 3 name price $.stock\n1) \"2\"\n2) \"item:1\"\n3) 1) \"name\"\n2) \"Noise-cancelling Bluetooth headphones\"\n3) \"price\"\n4) \"99.98\"\n5) \"$.stock\"\n6) \"25\"\n4) \"item:2\"\n5) 1) \"name\"\n2) \"Wireless earbuds\"\n3) \"price\"\n4) \"64.99\"\n5) \"$.stock\"\n6) \"17\"\nNote that the returned property name is the JSONPath expression itself: \"$.stock\"\n.\nYou can use the AS\noption to specify an alias for the returned property:\n127.0.0.1:6379> FT.SEARCH itemIdx '@description:(headphones)' RETURN 5 name price $.stock AS stock\n1) \"2\"\n2) \"item:1\"\n3) 1) \"name\"\n2) \"Noise-cancelling Bluetooth headphones\"\n3) \"price\"\n4) \"99.98\"\n5) \"stock\"\n6) \"25\"\n4) \"item:2\"\n5) 1) \"name\"\n2) \"Wireless earbuds\"\n3) \"price\"\n4) \"64.99\"\n5) \"stock\"\n6) \"17\"\nThis query returns the field as the alias \"stock\"\ninstead of the JSONPath expression \"$.stock\"\n.\nHighlight search terms\nYou can highlight relevant search terms in any indexed TEXT\nattribute.\nFor FT.SEARCH\n, you have to explicitly set which attributes you want highlighted after the RETURN\nand HIGHLIGHT\nparameters.\nUse the optional TAGS\nkeyword to specify the strings that will surround (or highlight) the matching search terms.\nFor example, highlight the word \"bluetooth\" with bold HTML tags in item names and descriptions:\n127.0.0.1:6379> FT.SEARCH itemIdx '(@name:(bluetooth))|(@description:(bluetooth))' RETURN 3 name description price HIGHLIGHT FIELDS 2 name description TAGS '<b>' '</b>'\n1) \"2\"\n2) \"item:1\"\n3) 1) \"name\"\n2) \"Noise-cancelling <b>Bluetooth</b> headphones\"\n3) \"description\"\n4) \"Wireless <b>Bluetooth</b> headphones with noise-cancelling technology\"\n5) \"price\"\n6) \"99.98\"\n4) \"item:2\"\n5) 1) \"name\"\n2) \"Wireless earbuds\"\n3) \"description\"\n4) \"Wireless <b>Bluetooth</b> in-ear headphones\"\n5) \"price\"\n6) \"64.99\"\nAggregate with JSONPath\nYou can use aggregation to generate statistics or build facet queries.\nThe LOAD\noption accepts JSONPath expressions. You can use any value in the pipeline, even if the value is not indexed.\nThis example uses aggregation to calculate a 10% price discount for each item and sorts the items from least expensive to most expensive:\n127.0.0.1:6379> FT.AGGREGATE itemIdx '*' LOAD 4 name $.price AS originalPrice APPLY '@originalPrice - (@originalPrice * 0.10)' AS salePrice SORTBY 2 @salePrice ASC\n1) \"2\"\n2) 1) \"name\"\n2) \"Wireless earbuds\"\n3) \"originalPrice\"\n4) \"64.99\"\n5) \"salePrice\"\n6) \"58.491\"\n3) 1) \"name\"\n2) \"Noise-cancelling Bluetooth headphones\"\n3) \"originalPrice\"\n4) \"99.98\"\n5) \"salePrice\"\n6) \"89.982\"\nFT.AGGREGATE\nqueries require attribute\nmodifiers. Don't use JSONPath expressions in queries, except with the LOAD\noption, because the query parser doesn't fully support them.Index missing or empty values\nAs of v2.10, you can search for missing properties, that is, properties that do not exist in a given document, using the INDEXMISSING\noption to FT.CREATE\nin conjunction with the ismissing\nquery function with FT.SEARCH\n. You can also search for existing properties with no value (i.e., empty) using the INDEXEMPTY\noption with FT.CREATE\n. Both query types require DIALECT 2. Examples below:\nJSON.SET key:1 $ '{\"propA\": \"foo\"}'\nJSON.SET key:2 $ '{\"propA\": \"bar\", \"propB\":\"abc\"}'\nFT.CREATE idx ON JSON PREFIX 1 key: SCHEMA $.propA AS propA TAG $.propB AS propB TAG INDEXMISSING\n> FT.SEARCH idx 'ismissing(@propB)' DIALECT 2\n1) \"1\"\n2) \"key:1\"\n3) 1) \"$\"\n2) \"{\\\"propA\\\":\\\"foo\\\"}\"\nJSON.SET key:1 $ '{\"propA\": \"foo\", \"propB\":\"\"}'\nJSON.SET key:2 $ '{\"propA\": \"bar\", \"propB\":\"abc\"}'\nFT.CREATE idx ON JSON PREFIX 1 key: SCHEMA $.propA AS propA TAG $.propB AS propB TAG INDEXEMPTY\n> FT.SEARCH idx '@propB:{\"\"}' DIALECT 2\n1) \"1\"\n2) \"key:1\"\n3) 1) \"$\"\n2) \"{\\\"propA\\\":\\\"foo\\\",\\\"propB\\\":\\\"\\\"}\"\nIndex limitations\nSchema mapping\nDuring index creation, you need to map the JSON elements to SCHEMA\nfields as follows:\n- Strings as\nTEXT\n,TAG\n, orGEO\n. - Numbers as\nNUMERIC\n. - Booleans as\nTAG\n. - JSON array\n- Array of strings as\nTAG\norTEXT\n. - Array of numbers as\nNUMERIC\norVECTOR\n. - Array of geo coordinates as\nGEO\n. null\nvalues in such arrays are ignored.\n- Array of strings as\n- You cannot index JSON objects. Index the individual elements as separate attributes instead.\nnull\nvalues are ignored.\nSortable tags\nIf you create an index for JSON documents with a JSONPath leading to an array or to multiple values, only the first value is considered by the sort.",
  "title": "",
  "author": "",
  "publish_date": "",
  "source": "redis.io",
  "language": "auto",
  "word_count": 3490,
  "extraction_method": "article_trafilatura",
  "extraction_timestamp": "2025-11-06T14:19:18.574811",
  "batch_id": "20251106_023619",
  "link_id": "art_req18",
  "error": null,
  "article_id": "9fc7b53ed5c6"
}