{
  "success": true,
  "url": "https://cursor.com/docs/context/codebase-indexing",
  "content": "Context\nCodebase Indexing\nCodebase indexing enables semantic search across your local workspace files, building a searchable index for natural language queries to find relevant code across your entire codebase.\nHow it works\nCursor transforms your code into searchable vectors through a 7-step process:\nYour workspace files are securely synchronized with Cursor's servers to keep the index current and up-to-date.\nFiles are broken down into meaningful chunks that capture the essence of your codeâ€”functions, classes, and logical code blocks rather than arbitrary text segments.\nEach chunk is converted into a vector representation using AI models. This creates a mathematical fingerprint that captures the semantic meaning of your code.\nThese embeddings are stored in a specialized vector database optimized for fast similarity search across millions of code chunks.\nWhen you search, your query is converted into a vector using the same AI models that processed your code.\nThe system finds the most similar code chunks by comparing your query's vector against stored embeddings.\nYou get relevant code snippets with file locations and context, ranked by semantic similarity to your search.\nYour workspace\nFile sync\nChunking\nAI embeddings\nVector database\nYour search query\nQuery embedding\nSearch results\nPrivacy and security\nData protection\nYour code's privacy is protected through multiple layers of security. File paths are encrypted before being sent to our servers, ensuring your project structure remains confidential. Your actual code content is never stored in plaintext on our servers, maintaining the confidentiality of your intellectual property. Code is only held in memory during the indexing process, then discarded, so there's no permanent storage of your source code.\nGetting started\nFirst-time indexing\nIndexing begins automatically when you open a workspace. The system scans your workspace structure, uploads files securely, and processes them through AI models to create embeddings. Semantic search becomes available at 80% completion.\nKeeping your index updated\nAutomatic sync\nCursor automatically keeps your index synchronized with your workspace through periodic checks every 5 minutes. The system intelligently updates only changed files, removing old embeddings and creating new ones as needed. Files are processed in batches for optimal performance, ensuring minimal impact on your development workflow.\nWhat gets indexed\nFile Type\tAction\nNew files\tAutomatically added to index\nModified files\tOld embeddings removed, fresh ones created\nDeleted files\tPromptly removed from index\nLarge/complex files\tMay be skipped for performance\nPerformance and troubleshooting\nPerformance: Uses intelligent batching and caching for accurate, up-to-date results.\nTroubleshooting steps:\nCheck internet connection\nVerify workspace permissions\nRestart Cursor\nContact support if issues persist\nThe indexing system works reliably in the background to keep your code searchable.\nWhy semantic search?\nWhile tools like grep and ripgrep are useful for finding exact string matches, semantic search goes further by understanding the meaning behind your code.\nIf you ask Agent to \"update the top navigation\", semantic search can find header.tsx even though the word \"navigation\" doesn't appear in the filename. This works because the embeddings understand that \"header\" and \"top navigation\" are semantically related.\nBenefits over grep alone\nSemantic search provides several advantages:\nFaster results: Compute happens during indexing (offline) rather than at runtime, so Agent searches are faster and cheaper\nBetter accuracy: Custom-trained models retrieve more relevant results than string matching\nFewer follow-ups: Users send fewer clarifying messages and use fewer tokens compared to grep-only search\nConceptual matching: Find code by what it does, not just what it's named\nAgent uses both grep and semantic search together. Grep excels at finding exact patterns, while semantic search excels at finding conceptually similar code. This combination delivers the best results.\nConfiguration\nCursor indexes all files except those in ignore files (e.g. .gitignore, .cursorignore).\nClick Show Settings to:\nEnable automatic indexing for new repositories\nConfigure which files to ignore\nIgnoring large content files improves answer accuracy.\nView indexed files\nTo see indexed file paths: Cursor Settings > Indexing & Docs > View included files\nThis opens a .txt file listing all indexed files.\nFAQ\nWhere can I see all indexed codebases?\nHow do I delete all indexed codebases?\nHow long are indexed codebases retained?\nIs my source code stored on Cursor servers?\nCan I customize path encryption?\nHow does team sharing work?\nWhat is smart index copying?\nDoes Cursor support multi-root workspaces?\nHow it works\nPrivacy and security\nData protection\nGetting started\nFirst-time indexing\nKeeping your index updated\nAutomatic sync\nWhat gets indexed\nPerformance and troubleshooting\nWhy semantic search?\nBenefits over grep alone\nConfiguration\nView indexed files\nFAQ\nCopy page\nShare feedback\nExplain more",
  "title": "Codebase Indexing",
  "author": "",
  "publish_date": "",
  "source": "cursor.com",
  "language": "auto",
  "word_count": 741,
  "extraction_method": "article_playwright",
  "extraction_timestamp": "2025-11-06T14:13:58.794627",
  "batch_id": "20251106_023619",
  "link_id": "art_req1",
  "error": null,
  "article_id": "b7f5d1d9dbf4"
}