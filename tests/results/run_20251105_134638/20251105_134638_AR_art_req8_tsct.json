{
  "success": true,
  "url": "https://docs.weaviate.io/weaviate/concepts/vector-index",
  "content": "Vector Indexing\nWhat is vector indexing? It's a key component of vector databases that helps to significantly increase the speed of the search process of similarity search with only a minimal tradeoff in search accuracy (HNSW index), or efficiently store many subsets of data in a small memory footprint (flat index). The dynamic index can even start off as a flat index and then dynamically switch to the HNSW index as it scales past a threshold.\nWeaviate's vector-first storage system takes care of all storage operations with a vector index. Storing data in a vector-first manner not only allows for semantic or context-based search, but also makes it possible to store very large amounts of data without decreasing performance (assuming scaled well horizontally or having sufficient shards for the indexes).\nWeaviate supports these vector index types:\n- flat index: a simple, lightweight index that is designed for small datasets.\n- HNSW index: a more complex index that is slower to build, but it scales well to large datasets as queries have a logarithmic time complexity.\n- dynamic index: allows you to automatically switch from a flat index to an HNSW index as object count scales\nThis page explains what vector indexes are, and what purpose they serve in the Weaviate vector database.\nIn vector databases, a vector index is a data structure that organizes vector embeddings to enable efficient similarity search. Indexing vector databases properly is crucial for performance, and different index types serve different purposes - from the simple flat index to more sophisticated approaches like HNSW.\nWhy do you need vector indexing?\nVector embeddings are a great way to represent meaning. Understanding how to index a vector is crucial for working with vector databases effectively. Vectors embeddings are arrays of elements that can capture meaning from different data types, such as texts, images, videos, and other content. The number of elements are called dimensions. High dimension vectors capture more information, but they are harder to work with.\nVector databases make it easier to work with high dimensional vectors. Consider search; Vector databases efficiently measure semantic similarity between data objects. When you run a similarity search, a vector database like Weaviate uses a vectorized version of the query to find objects in the database that have vectors similar to the query vector.\nVectors are like coordinates in a multi-dimensional space. A very simple vector might represent objects, words in this case, in a 2-dimensional space.\nIn the graph below, the words Apple\nand Banana\nare shown close to each other. Newspaper\nand Magazine\nare also close to each other, but they are far away from Apple\nand Banana\nin the same vector space.\nWithin each pair, the distance between words is small because the objects have similar vector embeddings. The distance between the pairs is larger because the difference between the vectors is larger. Intuitively, fruits are similar to each other, but fruits are not similar to reading material.\nFor more details of this representation, see: (GloVe) and vector embeddings.\nAnother way to think of this is how products are placed in a supermarket. You'd expect to find Apples\nclose to Bananas\n, because they are both fruit. But when you are searching for a Magazine\n, you would move away from the Apples\nand Bananas\n, more towards the aisle with, for example, Newspapers\n. This is how the semantics of concepts can be stored in Weaviate as well, depending on the module you're using to calculate the numbers in the vectors. Not only words or text can be indexed as vectors, but also images, video, DNA sequences, etc. Read more about which model to use here.\nYou might be also interested in our blog post Vector search explained.\nLet's explore how to index a vector using different approaches supported by Weaviate. The first method is the HNSW index.\nHierarchical Navigable Small World (HNSW) index\nHierarchical Navigable Small World (HNSW) is an algorithm that works on multi-layered graphs. It is also an index type, and refers to vector indexes that are created using the HNSW algorithm. HNSW indexes enable very fast queries, but rebuilding the index when you add new vectors can be resource intensive.\nWeaviate's hnsw\nindex is a custom implementation of the Hierarchical Navigable Small World (HNSW) algorithm that offers full CRUD-support.\nAt build time, the HNSW algorithm creates a series of layers. At query time, the HNSW algorithm uses the layers to build a list of approximate nearest neighbors (ANN) quickly and efficiently.\nConsider this diagram of a vector index using HNSW.\nAn individual object can exist in more than one layer, but every object in the database is represented in the lowest layer (layer zero in the picture). The layer zero data objects are very well connected to each other. Each layer above the lowest layer has fewer data object, and fewer connections. The data objects in the higher layers correspond to the objects in the lower layers, but each higher layer has exponentially fewer objects than the layer below. The HNSW algorithm takes advantage of the layers to efficiently process large amounts of data.\nWhen a search query comes in, the HNSW algorithm finds the closest matching data points in the highest layer. Then, HNSW goes one layer deeper, and finds the closest data points in that layer to the ones in the higher layer. These are the nearest neighbors. The algorithm searches the lower layer to create a new list of nearest neighbors. Then, HNSW uses the new list and repeats the process on the next layer down. When it gets to the deepest layer, the HNSW algorithm returns the data objects closest to the search query.\nSince there are relatively few data objects on the higher layers, HNSW has to search fewer objects. This means HNSW 'jumps' over large amounts of data that it doesn't need to search. When a data store has only one layer, the search algorithm can't skip unrelated objects. It has to search significantly more data objects even though they are unlikely to match.\nHNSW is very fast, memory efficient, approach to similarity search. The memory cache only stores the highest layer instead of storing all of the data objects in the lowest layer. When the search moves from a higher layer to a lower one, HNSW only adds the data objects that are closest to the search query. This means HNSW uses a relatively small amount of memory compared to other search algorithms.\nHave another look at the diagram; it demonstrates how the HNSW algorithm searches. The search vector in the top layer connects to a partial result in layer one. The objects in layer one lead HNSW to the result set in layer zero. This allows HNSW to skip objects that are unrelated to the search query.\nInserting a vector into an HNSW index works in a similar way. The HNSW algorithm finds the closest data objects in the highest layer, and then moves down to the next layer. It continues until it finds the best place to insert the new vector. The HNSW algorithm then connects the new vector to the existing vectors in that layer.\nManaging search quality vs speed tradeoffs\nHNSW parameters can be adjusted to adjust search quality against speed.\nThe ef\nparameter is a critical setting for balancing the trade-off between search speed and quality.\nThe ef\nparameter dictates the size of the dynamic list used by the HNSW algorithm during the search process. A higher ef\nvalue results in a more extensive search, enhancing accuracy but potentially slowing down the query.\nIn contrast, a lower ef\nmakes the search faster but might compromise on accuracy. This balance is crucial in scenarios where either speed or accuracy is a priority. For instance, in applications where rapid responses are critical, a lower ef\nmight be preferable, even at the expense of some accuracy. Conversely, in analytical or research contexts where precision is paramount, a higher ef\nwould be more suitable, despite the increased query time.\nef\ncan be configured explicitly or dynamically. This feature is particularly beneficial in environments with varying query patterns. When ef\nis configured dynamically, Weaviate optimizes the balance between speed and recall based on real-time query requirements.\nTo enable dynamic ef\n, set ef\n: -1. Weaviate adjusts the size of the ANN list based on the query response limit. The calculation also takes into account the values of dynamicEfMin\n, dynamicEfMax\n, and dynamicEfFactor\n.\nDynamic ef\nThe ef\nparameter controls the size of the ANN list at query time. You can configure a specific list size or else let Weaviate configure the list dynamically. If you choose dynamic ef\n, Weaviate provides several options to control the size of the ANN list.\nThe length of the list is determined by the query response limit that you set in your query. Weaviate uses the query limit as an anchor and modifies the size of ANN list according to the values you set for the dynamicEf\nparameters.\ndynamicEfMin\nsets a lower bound on the list length.dynamicEfMax\nsets an upper bound on the list length.dynamicEfFactor\nsets a range for the list.\nTo keep search recall high, the actual dynamic ef\nvalue stays above dynamicEfMin\neven if the query limit is small enough to suggest a lower value.\nTo keep search speed reasonable even when retrieving large result sets, the dynamic ef\nvalue is limited to dynamicEfMax\n. Weaviate doesn't exceed dynamicEfMax\neven if the query limit is large enough to suggest a higher value. If the query limit is higher than dynamicEfMax\n, dynamicEfMax\ndoes not have any effect. In this case, dynamic ef\nvalue is equal to the query limit.\nTo determine the length of the ANN list, Weaviate multiples the query limit by dynamicEfFactor\n. The list range is modified by dynamicEfMin\nand dynamicEfMax\n.\nConsider this GraphQL query that sets a limit of 4.\n{\nGet {\nJeopardyQuestion(limit: 4) {\nanswer\nquestion\n}\n}\n}\nImagine the collection has dynamic ef\nconfigured.\n\"vectorIndexConfig\": {\n\"ef\": -1,\n\"dynamicEfMin\": 5\n\"dynamicEfMax\": 25\n\"dynamicEfFactor\": 10\n}\nThe resulting search list has these characteristics.\n- A potential length of 40 objects ( (\"dynamicEfFactor\": 10) * (limit: 4) ).\n- A minimum length of 5 objects (\"dynamicEfMin\": 5).\n- A maximum length of 25 objects (\"dynamicEfMax\": 25).\n- An actual size of 5 to 25 objects.\nIf you use the docker-compose.yml\nfile from Weaviate to run your local instance, the QUERY_DEFAULTS_LIMIT\nenvironment variable sets a reasonable default query limit. To prevent out of memory errors,QUERY_DEFAULTS_LIMIT\nis significantly lower than QUERY_MAXIMUM_RESULTS\n.\nTo change the default limit, edit the value for QUERY_DEFAULTS_LIMIT\nwhen you configure your Weaviate instance.\nDeletions\nCleanup is an async process runs that rebuilds the HNSW graph after deletes and updates. Prior to cleanup, objects are marked as deleted, but they are still connected to the HNSW graph. During cleanup, the edges are reassigned and the objects are deleted for good.\nAsynchronous indexing\nThis feature relates to the vector index, specifically only to the HNSW index.\nAsynchronous indexing can be enabled by opting in as follows:\n- Open-source users can do this by setting the\nASYNC_INDEXING\nenvironment variable totrue\n. - Weaviate Cloud users can do this by toggling the\nEnable async indexing\nswitch in the Weaviate Cloud Console.\nWith synchronous indexing, the vector index is updated in lockstep with the object store. Updating an HNSW index can be an expensive operation, especially as the size of the index grows. As a result, the indexing operation can be the bottleneck in the system, slowing down the time for user requests to be completed.\nWhen asynchronous indexing is enabled, all vector indexing operations go through a queue. This applies to not only batch imports, but also to single object imports, deletions, and updates.\nThis means that the object store can be updated quickly to finish performing user requests while the vector index updates in the background. Asynchronous indexing is especially useful for importing large amounts of data.\nThis means that there will be a short delay between object creation and the object being available for vector search using the HNSW index. The number of objects in the queue can be monitored per node as shown here.\nv1.28\nIn Weaviate v1.22\nto v1.27\n, the async indexing feature only affected batch import operations, using an in-memory queue.\nStarting in v1.28\n, the async indexing feature has been expanded to include single object imports, deletions, and updates. Additionally, the in-memory queue has been replaced with a persistent, on-disk queue. This change allows for more robust handling of indexing operations, and improves performance though reduction of lock contention and memory usage.\nThe use of an on-disk queue may result in a slight increase in disk usage, however this is expected to be a small percentage of the total disk usage.\nFlat index\nv1.23\nThe flat index is one of the fundamental ways to implement vector indexing in databases. As the name suggests, it's a simple, lightweight index that is fast to build and has a very small memory footprint. This index type is a good choice for use cases where each end user (i.e. tenant) has their own, isolated, dataset, such as in a SaaS product for example, or a database of isolated record sets.\nAs the name suggests, the flat index is a single layer of disk-backed data objects and thus a very small memory footprint. The flat index is a good choice for small collections, such as for multi-tenancy use cases.\nA drawback of the flat index is that it does not scale well to large collections as it has a linear time complexity as a function of the number of data objects, unlike the hnsw\nindex which has a logarithmic time complexity.\nDynamic index\nAvailable starting in v1.25\n. This is an experimental feature. Use with caution.\nASYNC_INDEXING\nDynamic indexes require asynchronous indexing. To enable asynchronous indexing in a self-hosted Weaviate instance, set the ASYNC_INDEXING\nenvironment variable to true\n. If your instance is hosted in Weaviate Cloud, use the Weaviate Cloud console to enable asynchronous indexing.\nThe flat index is ideal for use cases with a small object count and provides lower memory overhead and good latency. As the object count increases the HNSW index provides a more viable solution as HNSW speeds up search. The goal of the dynamic index is to shorten latencies during querying time at the cost of a larger memory footprint as you scale.\nBy configuring a dynamic index, you can automatically switch from flat to HNSW indexes. This switch occurs when the object count exceeds a prespecified threshold (by default 10,000). This functionality only works with async indexing enabled. When the threshold is hit while importing, all the data piles up in the async queue, the HNSW index is constructed in the background and when ready the swap from flat to HNSW is completed.\nCurrently, this is only a one-way upgrade from a flat to an HNSW index, it does not support changing back to a flat index even if the object count goes below the threshold due to deletion.\nThis is particularly useful in a multi-tenant setup where building an HNSW index per tenant would introduce extra overhead. With a dynamic index, as individual tenants grow their index will switch from flat to HNSW, while smaller tenants' indexes remain flat.\nVector cache considerations\nFor optimal search and import performance, previously imported vectors need to be in memory. A disk lookup for a vector is orders of magnitudes slower than memory lookup, so the disk cache should be used sparingly. However, Weaviate can limit the number of vectors in memory. By default, this limit is set to one trillion (1e12\n) objects when a new collection is created.\nDuring import set vectorCacheMaxObjects\nhigh enough that all vectors can be held in memory. Each import requires multiple searches. Import performance drops drastically when there isn't enough memory to hold all of the vectors in the cache.\nAfter import, when your workload is mostly querying, experiment with vector cache limits that are less than your total dataset size.\nVectors that aren't currently in cache are added to the cache if there is still room. If the cache fills, Weaviate drops the whole cache. All future vectors have to be read from disk for the first time. Then, subsequent queries run against the cache until it fills again and the procedure repeats. Note that the cache can be a very valuable tool if you have a large dataset, and a large percentage of users only query a specific subset of vectors. In this case you might be able to serve the largest user group from cache while requiring disk lookups for \"irregular\" queries.\nVector indexing FAQ\nCan I use vector indexing with vector quantization?\nYes, you can read more about it in vector quantization (compression).\nWhich vector index is right for me?\nA simple heuristic is that for use cases such as SaaS products where each end user (i.e. tenant) has their own, isolated, dataset, the flat\nindex is a good choice. For use cases with large collections, the hnsw\nindex may be a better choice.\nNote that the vector index type parameter only specifies how the vectors of data objects are indexed. The index is used for data retrieval and similarity search.\nThe vectorizer\nparameter determines how the data vectors are created (which numbers the vectors contain). vectorizer\nspecifies a module, such as text2vec-contextionary\n, that Weaviate uses to create the vectors. (You can also set to vectorizer\nto none\nif you want to import your own vectors).\nTo learn more about configuring the collection, see this how-to page.\nWhich distance metrics can I use with vector indexing?\nAll of the distance metrics, such as cosine similarity, can be used with any vector index type.\nHow to configure the vector index type in Weaviate?\nThe index type can be specified per data collection via the collection definition settings, according to available vector index settings.\nWhen to skip indexing\nThere are situations where it doesn't make sense to vectorize a collection. For example, if the collection consists solely of references between two other collections, or if the collection contains mostly duplicate elements.\nImporting duplicate vectors into HNSW is very expensive. The import algorithm checks early on if a candidate vector's distance is greater than the worst candidate's distance. When there are lots of duplicate vectors, this early exit condition is never met so each import or query results in an exhaustive search.\nTo avoid indexing a collection, set \"skip\"\nto \"true\"\n. By default, collections are indexed.\nWhat ANN algorithms exist?\nThere are different ANN algorithms, you can find a nice overview of them on this website.\nAre there indicative benchmarks for Weaviate's ANN performance?\nThe ANN benchmark page contains a wide variety of vector search use cases and relative benchmarks. This page is ideal for finding a dataset similar to yours and learning what the most optimal settings are.\nFurther resources\nQuestions and feedback\nIf you have any questions or feedback, let us know in the user forum.",
  "title": "",
  "author": "",
  "publish_date": "",
  "source": "docs.weaviate.io",
  "language": "auto",
  "word_count": 3184,
  "extraction_method": "article_trafilatura",
  "extraction_timestamp": "2025-11-05T21:46:47.638624",
  "batch_id": "20251105_134638",
  "link_id": "art_req8",
  "error": null,
  "article_id": "5a7ac64b70b8",
  "summary": {
    "transcript_summary": {
      "key_facts": [
        "FACT: Vector indexing is a data structure that organizes vector embeddings to enable efficient similarity search in vector databases.",
        "FACT: Weaviate's vector-first storage system uses vector indexes to maintain performance when storing large amounts of data.",
        "FACT: The HNSW index uses multi-layered graphs to achieve logarithmic time complexity for queries, enabling fast scalability.",
        "FACT: The flat index is a lightweight, single-layer index suitable for small datasets and multi-tenancy use cases.",
        "FACT: The dynamic index automatically switches from flat to HNSW index when object count exceeds 10,000 (default threshold).",
        "FACT: Asynchronous indexing allows vector index updates to occur in the background, improving request response times.",
        "FACT: HNSW index rebuilds are resource-intensive, especially after deletions or updates, requiring cleanup processes.",
        "FACT: Vector embeddings represent meaning across text, images, video, and DNA sequences using high-dimensional arrays.",
        "FACT: The ef parameter controls the size of the approximate nearest neighbor list during HNSW queries, affecting speed vs. accuracy.",
        "FACT: Dynamic ef adjusts the ANN list size based on query limit, with bounds defined by dynamicEfMin, dynamicEfMax, and dynamicEfFactor.",
        "FACT: Vector cache stores recently accessed vectors in memory to reduce disk lookups and improve search performance.",
        "FACT: When the vector cache fills, older vectors are dropped, forcing future queries to read from disk until cache reloads.",
        "FACT: Vector quantization can be used alongside vector indexing to reduce memory usage through compression.",
        "FACT: The vectorizer module determines how input data is converted into vector embeddings, such as with text2vec-contextionary.",
        "FACT: Collections can be configured to skip indexing if they contain only references or duplicates, avoiding inefficiencies."
      ],
      "key_opinions": [
        "OPINION: The dynamic index offers a pragmatic solution for scaling multi-tenant systems without upfront HNSW overhead.",
        "OPINION: Asynchronous indexing is essential for high-throughput environments where low-latency user operations are critical.",
        "OPINION: HNSW’s layered approach provides superior performance over flat indexing at scale, despite higher build costs.",
        "OPINION: Dynamic ef configuration enables intelligent trade-offs between recall and speed tailored to real-time workloads.",
        "OPINION: Flat indexes remain ideal for isolated, small-scale datasets where simplicity and low memory usage are priorities.",
        "OPINION: Skipping indexing for duplicate-heavy collections prevents unnecessary computational waste and performance degradation.",
        "OPINION: The vector-first design of Weaviate fundamentally enhances semantic search capabilities across diverse data types."
      ],
      "key_datapoints": [
        "DATA: HNSW index has logarithmic time complexity for queries, unlike flat index’s linear time complexity.",
        "DATA: Default threshold for dynamic index switch is 10,000 objects.",
        "DATA: ef parameter value can be set explicitly or dynamically (ef: -1) to optimize speed vs. accuracy.",
        "DATA: dynamicEfMin defaults to 5, dynamicEfMax defaults to 25, and dynamicEfFactor defaults to 10.",
        "DATA: Query limit of 4 with dynamicEfFactor=10 results in a potential ANN list size of 40 objects.",
        "DATA: Vector cache default limit is set to 1 trillion (1e12) objects per new collection.",
        "DATA: Asynchronous indexing in v1.28 uses an on-disk queue, replacing the previous in-memory queue.",
        "DATA: Disk lookup for vectors is orders of magnitude slower than memory lookup.",
        "DATA: Import performance drops drastically if vector cache cannot hold all imported vectors.",
        "DATA: Weaviate supports all distance metrics including cosine similarity across any index type.",
        "DATA: QUERY_DEFAULTS_LIMIT is set lower than QUERY_MAXIMUM_RESULTS to prevent out-of-memory errors.",
        "DATA: HNSW index rebuilds occur asynchronously after deletions and updates via cleanup process.",
        "DATA: Dynamic index currently supports one-way upgrade from flat to HNSW, not reverse.",
        "DATA: Vector quantization is compatible with vector indexing for compression purposes.",
        "DATA: ANN benchmark page includes diverse use cases and optimal settings for different workloads."
      ],
      "topic_areas": [
        "Vector indexing types",
        "HNSW algorithm mechanics",
        "Dynamic index behavior",
        "Asynchronous indexing",
        "Vector cache optimization",
        "ef parameter tuning",
        "Flat index use cases",
        "Multi-tenancy indexing",
        "Performance tradeoffs",
        "Indexing best practices"
      ],
      "word_count": 3184,
      "total_markers": 37
    },
    "comments_summary": {},
    "created_at": "2025-11-05T21:49:03.219668",
    "model_used": "qwen-flash"
  }
}