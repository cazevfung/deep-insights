{
  "success": true,
  "url": "https://read.engineerscodex.com/p/how-cursor-indexes-codebases-fast",
  "content": "How Cursor Indexes Codebases Fast\nMerkle Trees in the real world\nEngineer’s Codex is a publication about real-world software engineering.\nCursor, the popular AI IDE that recently announced they hit $300M ARR, uses Merkle trees to index code fast. This post goes over exactly how.\nBefore diving into Cursor's implementation, let's first understand what a Merkle tree is.\nMerkle Trees Explained Simply\nA Merkle tree is a tree structure in which every \"leaf\" node is labeled with the cryptographic hash of a data block, and every non-leaf node is labeled with the cryptographic hash of the labels of its child nodes. This creates a hierarchical structure where changes at any level can be efficiently detected by comparing hash values.\nThink of them as a fingerprinting system for data:\nEach piece of data (like a file) gets its own unique fingerprint (hash)\nPairs of fingerprints are combined and given a new fingerprint\nThis process continues until you have just one master fingerprint (the root hash)\nThe root hash summarizes all data contained in the individual pieces, serving as a cryptographic commitment to the entire dataset. The beauty of this approach is that if any single piece of data changes, it will change all the fingerprints above it, ultimately changing the root hash.\nSWE Quiz (Sponsored)\nTop software engineers know a lot. But how do you know what you don’t know?\nSWE Quiz is a platform with roadmaps on system design fundamentals, like API design, databases, and more. There are three roadmaps launching in June: distributed systems, LLM fundamentals, and a React interview roadmap.\nGet lifetime access to SWE Quiz, used by devs who have used the platform to get into companies like Google, Meta, and Airbnb.\nHow Cursor Uses Merkle Trees for Codebase Indexing\nCursor uses Merkle trees as a core component of its codebase indexing feature. According to a post by Cursor's founder and the security documentation, here's how it works:\nStep 1: Code Chunking and Processing\nCursor first chunks your codebase files locally, splitting code into semantically meaningful pieces before any processing occurs.\nStep 2: Merkle Tree Construction and Synchronization\nWhen codebase indexing is enabled, Cursor scans the folder opened in the editor and computes a Merkle tree of hashes of all valid files. This Merkle tree is then synchronized with Cursor's server, as detailed in Cursor's security documentation.\nStep 3: Embedding Generation\nAfter the chunks are sent to Cursor's server, embeddings are created using either OpenAI's embedding API or a custom embedding model (I couldn’t verify this). These vector representations capture the semantic meaning of the code chunks.\nStep 4: Storage and Indexing\nThe embeddings, along with metadata like start/end line numbers and file paths, are stored in a remote vector database (Turbopuffer). To maintain privacy while still enabling path-based filtering, Cursor stores an obfuscated relative file path with each vector. Importantly, according to Cursor's founder, \"None of your code is stored in our databases. It's gone after the life of the request.\"\nStep 5: Periodic Updates Using Merkle Trees\nEvery 10 minutes, Cursor checks for hash mismatches, using the Merkle tree to identify which files have changed. Only the changed files need to be uploaded, significantly reducing bandwidth usage, as explained in Cursor's security documentation. This is where the Merkle tree structure provides its greatest value—enabling efficient incremental updates.\nCode Chunking Strategies\nThe effectiveness of the codebase indexing largely depends on how code is chunked. While my previous explanation didn't go into detail about chunking methods, this blog post about building a Cursor-like codebase feature provides some insights:\nWhile simple approaches split code by characters, words, or lines, they often miss semantic boundaries—resulting in degraded embedding quality.\nYou can split code based on a fixed token count, but this can cut off code blocks like functions or classes mid-way.\nA more effective approach is to use an intelligent splitter that understands code structure, such as recursive text splitters that use high-level delimiters (e.g., class and function definitions) to split at appropriate semantic boundaries.\nAn even more elegant solution is to split the code based on its Abstract Syntax Tree (AST) structure. By traversing the AST depth-first, it splits code into sub-trees that fit within token limits. To avoid creating too many small chunks, sibling nodes are merged into larger chunks as long as they stay under the token limit. Tools like tree-sitter can be used for this AST parsing, supporting a wide range of programming languages.\nFor a crash course on tokens, read this.\nHow Embeddings Are Used at Inference Time\nAfter covering how Cursor creates and stores code embeddings, a natural question arises: how are these embeddings actually used once they've been generated? This section explains the practical application of these embeddings during normal usage.\nSemantic Search and Context Retrieval\nWhen you interact with Cursor's AI features like asking questions about your codebase (using @Codebase or ⌘ Enter), the following process occurs:\nQuery Embedding: Cursor computes an embedding for your question or the code context you're working with.\nVector Similarity Search: This query embedding is sent to Turbopuffer (Cursor's vector database), which performs a nearest-neighbor search to find code chunks semantically similar to your query.\nLocal File Access: Cursor's client receives the results, which include obfuscated file paths and line ranges of the most relevant code chunks. Importantly, the actual code content remains on your machine and is retrieved locally.\nContext Assembly: The client reads these relevant code chunks from your local files and sends them as context to the server for the LLM to process alongside your question.\nInformed Response: The LLM now has the necessary context from your codebase to provide a more informed and relevant response to your question or to generate appropriate code completions.\nThis embedding-powered retrieval allows for:\nContextual Code Generation: When writing new code, Cursor can reference similar implementations in your existing codebase, maintaining consistent patterns and styles.\nCodebase Q&A: You can ask questions about your codebase and get answers informed by your actual code rather than generic responses.\nSmart Code Completion: Code completions can be enhanced with awareness of your project's specific conventions and patterns.\nIntelligent Refactoring: When refactoring code, the system can identify all related pieces across your codebase that might need similar changes.\nWhy Cursor Uses Merkle Trees\nMany of these details are security-related, and thus can be found in Cursor’s security documentation.\n1. Efficient Incremental Updates\nBy using a Merkle tree, Cursor can quickly identify exactly which files have changed since the last synchronization. Instead of re-uploading the entire codebase, it only needs to upload the specific files that have been modified. This is important for large codebases where re-indexing everything would be too expensive in terms of bandwidth and processing time.\n2. Data Integrity Verification\nThe Merkle tree structure allows Cursor to efficiently verify that the files being indexed match what's stored on the server. The hierarchical hash structure makes it easy to detect any inconsistencies or corrupted data during transfer.\n3. Optimized Caching\nCursor stores embeddings in a cache indexed by the hash of the chunk, ensuring that indexing the same codebase a second time is much faster. This is great for teams where multiple developers might be working with the same codebase.\n4. Privacy-Preserving Indexing\nTo protect sensitive information in file paths, Cursor implements path obfuscation by splitting the path by '/' and '.' characters and encrypting each segment with a secret key stored on the client. While this still reveals some information about directory hierarchy, it hides most sensitive details.\n5. Git History Integration\nWhen codebase indexing is enabled in a Git repository, Cursor also indexes the Git history. It stores commit SHAs, parent information, and obfuscated file names. To enable sharing the data structure for users in the same Git repo and on the same team, the secret key for obfuscating file names is derived from hashes of recent commit contents.\nEmbedding Models and Considerations\nThe choice of embedding model significantly impacts the quality of code search and understanding. While some systems use open-source models like all-MiniLM-L6-v2, Cursor likely uses either OpenAI's embedding models or custom embedding models specifically tuned for code. For specialized code embeddings, models like Microsoft's unixcoder-base or Voyage AI's voyage-code-2 are good for code-specific semantic understanding.\nThe embedding challenge is made more complex because embedding models have token limits. OpenAI's text-embedding-3-small model, for example, has a token limit of 8192. Effective chunking helps stay within token limits while preserving semantic meaning.\nThe Handshake Process\nA key aspect of Cursor's Merkle tree implementation is the handshake process that occurs during synchronization. Logs from the Cursor application reveal that when initializing codebase indexing, Cursor creates a \"merkle client\" and performs a \"startup handshake\" with the server. This handshake involves sending the root hash of the locally computed Merkle tree to the server, as seen in Issue #2209 on GitHub and Issue #981 on GitHub.\nThe handshake process allows the server to determine which parts of the codebase need to be synced. Based on the handshake logs, we can see that Cursor computes the initial hash of the codebase and sends it to the server for verification, as documented in Issue #2209 on GitHub.\nTechnical Implementation Challenges\nWhile the Merkle tree approach offers many advantages, it's not without implementation challenges. Cursor's indexing feature often experiences heavy load, causing many requests to fail. This can result in files needing to be uploaded several times before they get fully indexed. Users might notice higher than expected network traffic to 'repo42.cursor.sh' as a result of these retry mechanisms, as mentioned in Cursor's security documentation.\nAnother challenge relates to embedding security. Academic research has shown that reversing embeddings is possible in some cases. While current attacks typically rely on having access to the embedding model and working with short strings, there is a potential risk that an adversary who gains access to Cursor's vector database could extract information about indexed codebases from the stored embeddings.",
  "title": "",
  "author": "",
  "publish_date": "",
  "source": "read.engineerscodex.com",
  "language": "auto",
  "word_count": 1651,
  "extraction_method": "article_trafilatura",
  "extraction_timestamp": "2025-11-05T21:55:25.684581",
  "batch_id": "20251105_135520",
  "link_id": "art_req2",
  "error": null,
  "article_id": "04d0c25fd54d",
  "summary": {
    "transcript_summary": {
      "key_facts": [
        "FACT: Cursor uses Merkle trees to efficiently index codebases by creating a hierarchical hash structure from code chunks.",
        "FACT: Code is split into semantically meaningful chunks before being processed for indexing in Cursor.",
        "FACT: Cursor computes a Merkle tree of file hashes locally and synchronizes the root hash with its server.",
        "FACT: Embeddings are generated from code chunks using either OpenAI's API or a custom embedding model.",
        "FACT: Vector embeddings are stored in Turbopuffer, a remote vector database, with obfuscated file paths.",
        "FACT: Cursor does not store actual code content in its databases; data is discarded after the request lifecycle.",
        "FACT: Every 10 minutes, Cursor checks for hash mismatches using the Merkle tree to detect changed files.",
        "FACT: Only modified files are re-uploaded during incremental updates, reducing bandwidth usage significantly.",
        "FACT: Code chunking strategies include token-based splitting, recursive text splitters, and AST-based parsing.",
        "FACT: AST traversal using tools like tree-sitter enables semantic-aware splitting that respects function and class boundaries.",
        "FACT: Query embeddings are compared against stored vectors in Turbopuffer to retrieve relevant code context.",
        "FACT: Retrieved results include obfuscated file paths and line ranges, but actual code is read locally from user machines.",
        "FACT: The LLM receives local code context alongside queries to generate accurate, project-specific responses.",
        "FACT: Merkle tree root hashes are sent during a handshake process to initiate synchronization with the server.",
        "FACT: Git history is indexed when enabled, storing commit SHAs, parent info, and obfuscated file names."
      ],
      "key_opinions": [
        "OPINION: The Merkle tree approach enables efficient and secure codebase indexing at scale.",
        "OPINION: Intelligent code chunking based on AST structure leads to higher-quality embeddings than simple token limits.",
        "OPINION: Path obfuscation provides a reasonable balance between privacy and functional utility in shared environments.",
        "OPINION: Embedding models tuned for code, such as unixcoder-base, offer superior performance over general-purpose models.",
        "OPINION: The handshake mechanism ensures integrity and consistency during initial codebase sync.",
        "OPINION: Incremental updates via Merkle trees are essential for maintaining responsiveness in large codebases.",
        "OPINION: Heavy load during indexing suggests potential scalability bottlenecks in Cursor’s current architecture.",
        "OPINION: The risk of embedding reversal, while low today, warrants ongoing security monitoring.",
        "OPINION: Using client-side secret keys derived from Git history enhances team-level collaboration security.",
        "OPINION: Privacy-preserving indexing is critical for enterprise adoption of AI-powered IDEs."
      ],
      "key_datapoints": [
        "DATA: Cursor achieved $300M in annual recurring revenue (ARR).",
        "DATA: Cursor checks for file changes every 10 minutes using Merkle tree comparisons.",
        "DATA: OpenAI's text-embedding-3-small model has a token limit of 8192.",
        "DATA: Embeddings are cached using chunk hash keys, enabling faster re-indexing.",
        "DATA: File paths are obfuscated by splitting on '/' and '.' and encrypting each segment.",
        "DATA: The Merkle tree root hash is transmitted during the startup handshake with the server.",
        "DATA: Cursor's vector database is Turbopuffer.",
        "DATA: Code chunks are stored with metadata including start/end line numbers and file paths.",
        "DATA: Embedding generation occurs after code chunks are sent to Cursor's server.",
        "DATA: Retries occur frequently due to high indexing load, increasing network traffic to 'repo42.cursor.sh'."
      ],
      "topic_areas": [
        "Merkle tree implementation",
        "Codebase indexing",
        "Vector embeddings",
        "Incremental updates",
        "Privacy-preserving design",
        "AST-based chunking",
        "Semantic search",
        "Embedding security",
        "Git integration",
        "AI IDE architecture"
      ],
      "word_count": 1651,
      "total_markers": 35
    },
    "comments_summary": {},
    "created_at": "2025-11-05T21:57:08.794420",
    "model_used": "qwen-flash"
  }
}