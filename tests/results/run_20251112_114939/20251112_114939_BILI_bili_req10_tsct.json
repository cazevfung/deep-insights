{
  "success": true,
  "bv_id": "BV1TSg7zuEqR",
  "url": "https://www.bilibili.com/video/BV1TSg7zuEqR/",
  "content": "今天我们来聊聊agent，它也叫AI agent，这是一个随着大模型热潮而兴起的重要概念，虽然agent这个词现在被频繁的提起，但它究竟是什么，是如何运作的，很多人其实并不清楚。所以在这个视频里面，我会带你彻底搞明白这两个问题。在正式开始前，我需要先提醒一下，视频前半部分的一些内容和我之前发过的mp终极指南番外篇有所重合。如果你已经看过那一篇了，那这个视频就建议从react代码的实现部分开始观看。大家都知道现在的大模型，比如gp 4o deep sick之类的，他们回答问题很厉害，逻辑也很强，但平时我们用他们的时候呢，会发现一个限制，他们无法感知或者是改变外界环境。这句话是什么意思呢，我举一个例子来给你说明一下，比如你想让gb 4o帮你写一个贪吃蛇游戏，他确实可以给你代码，但是写完之后，像把代码写入到文件这种事情还是得你自己动手。也就是说，大模型无法改变外界环境，而且有没有一种可能，你其实已经有一些贪吃蛇的代码了，你只是想让模型帮你基于这些代码来改写，增加一些功能，在这种情况下，你就必须把你已有的代码复制给GBD4O才行。我们不主动告诉GBD4O的话，他是无法自己查到这些代码的，换句话说，这就是大模型无法感知外界环境的体现，所以综合来看，大模型是无法感知或者是改变外部环境的。那有没有办法解决掉这个问题呢？其实是有的，我们给他接上对应的工具就可以了。比如说是读写文件内容的工具，查看文件列表的工具，运行终端命令的工具。工具呢就像是大模型的感官和四肢，有了它大模型就可以自己查询已有文件，自己写入代码，自己运行程序，整个过程不需要我们插手，完全自动化，像这样把一个大模型和一堆工具组装起来，变成一个能感知和改变外界环境的智能程序，我们就称它为agent。通常agent用一个机器人来表示，这与大模型的大脑图标形成了鲜明的对比，毕竟agent有了感官和四肢嘛，能自己独立做事了，就像一个机器人一样。Agent呢有很多类型，前面举的是编程类的agent，它可以用来开发程序。除此之外还有一些agent可以做P T，有一些agent可以深度搜索等等等等。总的来说agent的类型有很多，擅长的领域呢也各不相同。下面我们来举几个具体点的例子。第一个例子便是大名鼎鼎的cursor。相信即使你没有使用过它，也多多少少听说过它的存在。Cursor是一个用于编程的agent，我们只需要给他提交任务，它便会调用大模型和各种工具来帮我们写代码，直至完成任务。整个过程中，你顶多点个确定按钮，别的基本上什么也不用动。再举一个例子，前一阵子比较火的minus它也是一个agent。在这个例子中用户希望minus帮他比较几个手机的性能、照相等能力。为了解决用户的问题，minus会生成执行计划，搜索并浏览相关网页，最后把报告整理成一个页面展示给用户看，整个过程基本上也不需要用户插手，minus利用大模型和一些工具就可以解决掉用户的问题。好，相信到这里呢你对agent就有一个大致的了解了。下面呢我们就来讲讲agent的运行模式。Agent的运行有很多种模式，其中最有名的一种是react。React本身是一个缩写，它的全称是reasoning and acting，也就是思考与行动。React可能是目前使用最为广泛的agent运行模式。如果你要学习agent的实现原理，那你就绝对绕不开react，这个模式最初由2022年10月份的一篇论文提出，虽然距离现在已经有接近三年的时间了，但是他所提出的agent的运行模式仍然有着非常广泛的使用。说他是目前使用最为广泛的A城的运行模式也不为过。在这种模式下，用户先提交任务，然后agent先做思考，英文是thought，他思考后会决定是否调用工具，如果是的话，他便会去调用合适的工具，比如读取文件，写入文件内容之类的。React称这一步是行动，英文是action。在行动后，agent会去查看工具的执行结果，比如所读取的文件内容，写入是否成功等等。React称这一步是观察，也就是观察工具执行结果。英文是observation，在观察之后，react会继续思考，他会再次判断是否需要调用工具，如果还是需要的话，他就会继续重复之前所说的行动观察思考的流程，直到某个时刻他认为不需要再调用工具了，可以直接给出结论了。此时他就输出了最终答案，英文是final answer，整个流程到此结束。所以从这个流程图里面也可以看出，react流程的核心步骤是thought、action、observation和final answer。记住这几个词，我们后面呢会用到。了解了react模式的流程之后，下一个问题就是这种react模式是如何实现的。为什么模型拿到用户问题之后会先思考再行动？他为什么不直接行动？是因为模型就这么训练的吗？不是的这跟模型的训练过程关系不大。大部分奥秘呢其实都集中在系统提示词上。系统提示词是跟用户问题一起送给模型的提示词。他规定了模型的角色运行时要遵守的规则，以及各种环境的信息等等。比如我们在系统提示词里面写，你的回答必须包含两个excl标签，一个叫做question，用于存放用户的问题，一个叫做answer，用于存放你的回答，你把这个系统提示词和用户问题一起发给大模型。在这种情况下，大模型便会遵循这种规范来输出答案。上面举的是一个简单的例子，如果你想要模型按照react模式返回答案的话呢，那你的系统提示词就会更加复杂一些。我这里呢就有一个具体点的例子，这个系统提示词大致有五个部分，分别是职责描述事例、可用工具、注意事项和环境信息。我们来仔细读一下。首先看职责描述部分，你需要解决一个任务，为此你需要将任务分解为多个步骤。对于每个步骤首先使用thought思考要做什么，然后使用action调用一个工具，工具的执行结果会通过observation返回给你持续这个思考和行动的过程，直到你有足够多的信息来提供final answer。这一段话呢其实就是在描述我们刚才的那个react执行流程图。我们希望大模型按照react这个标准来运作。后面呢则是专门说明了每个标签的功能。紧接着我举了几个例子，比如说第一个用户的问题是埃菲尔铁塔有多高？模型呢就先用thought标签做了一些思考，然后再使用action调用了get he工具常用的参数呢是埃菲尔铁塔工具的返回结果通过observation返回给了模型。模型接到结果之后呢，他再做了一些思考，然后就给出了最终的答案，这个就是一个非常典型的react流程。后面的例子二呢其实也是类似，只不过是他调用工具调了两遍啊，这个我们就不细说了。再往后我这里列举了一些可用的工具，分别用于读取文件内容，写入文件内容和运行终端命令，都是非常常用的功能，然后呢我们列举了一些注意事项就是在这里，而且告诉了大模型相关的一些环境信息，比如说是当前的操作系统目录和目录下的文件列表等等。下面我们就来演示一下如何使用这个系统提示词。我们用deep stick来举例，我们先把我们的系统提示词复制一下，然后粘贴进来作为用户输入的一部分。之后再在后面加上具体要完成的任务，写一个贪吃蛇游戏，使用htm l css和J S实现代码分别放在不同的文件中。有一点需要提一下，按照规范的做法，系统提示词和用户任务应该分开传给模型。但deep并没有提供单独提交系统提示词的地方，所以呢我们就把系统提示词和用户任务合在一起，当成一条消息提交给他。这样的处理方式在大多数的情况下也是没有问题的，模型依然能够按照预期运行。好，让我们提交任务，可以看到deep ck开始运行了让我们稍等一下，让他运行完毕。可以看出他按照我们的要求先在source标签里面思考了一下，然后他使用action标签请求调用right above工具来写入index dtl文件，这后面就是具体的文件内容了，大家注意我的措辞啊，大模型请求调用工具这里体现的是请求两个字，大模型本身是不能调用工具的，调用工具的是agent的工具，调用组件这里大模型只能是请求。现在如果运行的是一个真的agent的话，它便会去调用工具背后的right form函数写入H tm l文件内容。不过我们现在的模拟嘛，我们就假设调用已经完成了，并且假设工具的返回结果是写入成功，所以我们回复observation写入成功。拿到这个结果后，deep stick又开始运行了，这次他还是先用thought标签思考了一下，然后再使用action标签请求写入css文件的内容。我们照例回复写入成功，deep sick又开始返回了让我们稍等一下。可以看出deep Seeck还是先用thought思考，再用action请求写入gs s文件的内容，我们还是回复写入成功，然后deep sick的返回就有了些变化，因为三个必要的文件都已经写入完成了，不需要再调用工具了，因此deep Seeck的thought之后返回了一个final answer，整个回答就彻底结束了。你看，这就是react模式真正运行时的节奏，每一步都按照系统提示词的要求来，thought action observation, thought action observation, 一直到任务完成，此时会输出thoughts和final answer。系统提示词就相当于给模型安排了一个迷你剧本，他会严格按照这个剧本一步一步的走完。前面我们用deep演示了一个agent的运行流程，可以看到整个流程的关键在于系统提示词，它决定了模型该如何一步步运行。其实在这个系统提示词的基础上，再加上一些配套的代码，我们就可以搭建出一个真正可用的react agent。实际上我已经把这个agent写好了，就放在我的get help仓库里，有需要的同学可以自行获取。接下来我先演示一下这个agent的使用过程，随后再带大家一起看一遍它的代码。我已经进入到这个agent所处的项目目录了，我们先执行一下命令，看一下这个项目目录里面都有什么文件。这里文件很多啊，但实际上你只有两个文件需要留意一下。第一个是agent的pi文件，这个文件里面就写了我们的agent的代码，我们等会儿要运行的就是这个文件。另外一个是snake文件夹，它里面什么也没有。我用tree命令给你证实下，可以看出确实没有任何文件。等会儿我就会让agent把代码写入到这个文件夹里面。好，介绍完毕。下面我们来执行一下这个agent，让你看看他是如何运作的。首先我们启动一下这个agent，我们用的命令是uv run agpi snake。前面的uv run agent pe就是用来启动agent的pi文件的，后面的snake是agent pi这个脚本的第一个参数，意思是告诉agent的p他要操作的项目目录是snake代码就写在那里面，agent点p首先向我们询问需要完成的任务，我们的任务就是写一个贪吃蛇游戏。使用htm l css和J S实现代码分别放在不同的文件中回agent p已经开始运行了，它现在正在请求大模型，我这里采用了同步返回的机制，所以需要等模型把所有内容都生成完毕之后才能看到结果。其实也可以用流式返回的模型，返回几个字就能看到几个字，这样可能效果更好一点。不过代码的复杂度会增加，所以综合权衡之后我就没有使用流式返回。好看到第一轮的结果了。我们的结果一共是包含三个部分，thoughts、action、observation, 跟我们之前在deep sick那里看到的一模一样。这里的action是请求调用right for工具写入index点H tl文件后面的observation显示的就是具体的调用结果了。写入成功。注意啊，这个写入成功可不是模拟的这是真的执行了right for工具，工具也真的返回了写入成功这几个字。好，这个呢是第一部分，我们把滚动条往下拉一拉，看一下剩下的部分是个什么样子的。后面的流程呢也基本类似，可以看到在observation之后，agent会再次进修模型。然后agent就又进行了一段thought action observation，这一轮写入的是css我们再把滚动条往下拖一拖，在这里我们就可以看到第三轮的thought action observation，这次写入的是js最后所有文件都写完之后，他会给出thoughts和final answer，整个流程就结束了。再看看snake文件夹，确实三个文件都有了。执行index H天喵，看看游戏能不能玩。可以看到界面出来了，我们动一下啊，确实也是能动的。然后是一个红色的方块呢，也是可以吃的。左上角是分数，看来运转的非常顺畅。从这个结果中也可以判断出我们这个agent做的非常成功，完全可以作为一个简化版的cloud code来使用。下面我们来看一下这个agent的具体代码。我们首先从入口处看起，这里面的project directory就是我们传给agent的p文件的第一个参数，也就是snake那个文件夹。Tools代表可用的工具列表。我们这里给出了三个，分别用于读取文件、写入文件和运行终端命令。这些都是很实用的函数。我们可以大体看一下，这个呢是读取文件，这个是写入文件函数，这个呢是运行终端命令。从这里也可以看出，工具确实就是函数。让我们回到原来的主链路继续往下看，这里的react agent便是这个文件的核心了。它是一个类构造这个类的时候呢需要提供三个参数。第一个是工具列表，这个我们前面已经构建好了，这里直接传了进来。第二个是我们要用的模型，我们这里用的是gb d 4O第三个是项目目录，也就是snake文件夹。传好了这三个参数之后，我们便获取到了一个agent变量之后我们会提示用户输入任务内容。然后我们把用户任务传入agent点run函数，这个函数是react agent的核心，调用它就相当于是启动了这个agent。之前提到的thoughts，action, observation和final answer都是在这个函数内部意思处理的。他处理好了之后会给出一个最终答案，final answer, 并且把这个final answer输出到屏幕上，到这里主链路就结束了。可以看到这段代码的核心是react agents，我们来看一下它里面写了些什么。首先他这里定义了一些自身的属性，分别是工具列表、模型项目目录和模型调用客户端。到这里构造函数呢就结束了。后面我们要看的函数便是这个agent的重点run函数。这个函数的参数呢是用户输入的任务，在函数的内部它先构建了一个message列表，里面有两个元素，分别是系统提示词和用户问题。系统提示词是用render system prompts这个函数来渲染的。他接受一个参数是系统提示词模板，模板里面的内容是这个样子的。",
  "title": "",
  "author": "",
  "publish_date": "",
  "source": "Bilibili (via SnapAny + Paraformer)",
  "language": "zh-CN",
  "word_count": 6070,
  "extraction_method": "snapany_paraformer",
  "extraction_timestamp": "2025-11-12T19:57:30.052790",
  "batch_id": "20251112_114939",
  "link_id": "bili_req10",
  "error": null
}