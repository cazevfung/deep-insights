{
  "success": true,
  "url": "https://cursor.com/docs/configuration/tools/large-codebases",
  "content": "Cookbook\nLarge Codebases\nWorking with large codebases introduces a new set of challenges than working on smaller projects. Drawing from both our experience scaling Cursor's own codebase and insights from customers managing massive codebases, we've discovered some useful patterns for handling increased complexity.\nLet's explore some of these techniques that we've found be useful for large codebases.\nUse Chat to quickly get up to speed on unfamiliar code\nNavigating a large codebase, especially if it's new to you, can be challenging. You often grep, search, and click around to find the specific parts of the codebase you're looking for. With Chat, you can start asking questions to find what you're looking for and get a detailed explanation of how it works.\nHere we're getting help to find implementation details of codebase indexing in Cursor, and even asking for some examples to make it easier to understand.\nWrite rules for domain-specific knowledge\nIf you were onboarding a new collaborator into your codebase, what context would you give them to make sure they can start doing meaningful contributions?\nYour answer to this question is likely valuable information for Cursor to understand as well. For every organization or project, there's latent knowledge that might not be fully captured in your documentation. Using rules effectively is the single best way to ensure Cursor is getting the full picture.\nFor example, if you're writing instructions for how to implement a new feature or service, consider writing a short rule to document it for posterity.\n---\ndescription: Add a new VSCode frontend service\n---\n1. **Interface Definition:**\n- Define a new service interface using `createDecorator` and ensure `_serviceBrand` is included to avoid errors.\n2. **Service Implementation:**\n- Implement the service in a new TypeScript file, extending `Disposable`, and register it as a singleton with `registerSingleton`.\n3. **Service Contribution:**\n- Create a contribution file to import and load the service, and register it in the main entrypoint.\n4. **Context Integration:**\n- Update the context to include the new service, allowing access throughout the application.\nIf there are common formatting patterns that you want to make sure Cursor adheres to, consider auto-attaching rules based on glob patterns.\n---\nglobs: *.ts\n---\n- Use bun as package manager. See [package.json](mdc:backend/reddit-eval-tool/package.json) for scripts\n- Use kebab-case for file names\n- Use camelCase for function and variable names\n- Use UPPERCASE_SNAKE_CASE for hardcoded constants\n- Prefer `function foo()` over `const foo = () =>`\n- Use `Array<T>` instead of `T[]`\n- Use named exports over default exports, e.g (`export const variable ...`, `export function `)\nStay close to the plan-creation process\nFor larger changes, spending an above-average amount of thought to create a precise, well-scoped plan can significantly improve Cursor's output.\nIf you find that you're not getting the result you want after a few different variations of the same prompt, consider zooming out and creating a more detailed plan from scratch, as if you were creating a PRD for a coworker. Oftentimes the hard part is figuring out what change should be made, a task suited well for humans. With the right instructions, we can delegate some parts of the implementation to Cursor.\nOne way to use AI to augment the plan-creation process is to use Ask mode. To create a plan, turn on Ask mode in Cursor and dump whatever context you have from your project management systems, internal docs, or loose thoughts. Think about what files and dependencies you have in the codebase that you already know you want to include. This can be a file that includes pieces of code you want to integrate with, or perhaps a whole folder.\nHere's an example prompt:\nPlanning prompt\n- create a plan for how we shoud create a new feature (just like @existingfeature.ts)\n- ask me questions (max 3) if anything is unclear\n- make sure to search the codebase\n@Past Chats (my earlier exploration prompts)\nhere's some more context from [project management tool]:\n[pasted ticket description]\nWe're asking the model to create a plan and gather context by asking the human questions, referencing any earlier exploration prompts and also the ticket descriptions. Using a thinking model like claude-sonnet-4.5, gpt-5-codex, or gemini-2.5-pro is recommended as they can understand the intent of the change and better synthesize a plan.\nFrom this, you can iteratively formulate the plan with the help of Cursor before starting implementation.\nPick the right tool for the job\nOne of the most important skills in using Cursor effectively is choosing the right tool for the job. Think about what you're trying to accomplish and pick the approach that will keep you in flow.\nTool\tUse case\tStrength\tLimitation\nTab\tQuick, manual changes\tFull control, fast\tSingle-file\nInline Edit\tScoped changes in one file\tFocused edits\tSingle-file\nChat\tLarger, multi-file changes\tAuto-gathers context, deep edits\tSlower, context-heavy\nEach tool has its sweet spot:\nTab is your go-to for quick edits where you want to be in the driver's seat\nInline Edit shines when you need to make focused changes to a specific section of code\nChat is perfect for those bigger changes where you need Cursor to understand the broader context\nWhen you're using Chat mode (which can feel a bit slower but is incredibly powerful), help it help you by providing good context. Use @files to point to similar code you want to emulate, or @folder to give it a better understanding of your project structure. And don't be afraid to break bigger changes into smaller chunks - starting fresh chats helps keep things focused and efficient.\nTakeaways\nScope down changes and don't try to do too much at once\nInclude relevant context when you can\nUse Chat, Inline Edit & Tab for what they're best at\nCreate new chats often\nPlan with Ask mode, implement with Agent mode\nUse Chat to quickly get up to speed on unfamiliar code\nWrite rules for domain-specific knowledge\nStay close to the plan-creation process\nPick the right tool for the job\nTakeaways\nCopy page\nShare feedback\nExplain more",
  "title": "Large Codebases",
  "author": "",
  "publish_date": "",
  "source": "cursor.com",
  "language": "auto",
  "word_count": 999,
  "extraction_method": "article_playwright",
  "extraction_timestamp": "2025-11-05T19:14:58.369821",
  "batch_id": "20251105_111439",
  "link_id": "art_req2",
  "error": null,
  "article_id": "15323ffa9e37"
}