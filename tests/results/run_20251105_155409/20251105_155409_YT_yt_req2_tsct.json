{
  "success": true,
  "video_id": "3G293is403I",
  "url": "https://www.youtube.com/watch?v=3G293is403I",
  "content": "so we know indexing makes your database faster in this video we'll go through how exactly indexing makes your database faster we'll go through how indexes help you minimize the disk ios that needs to be done by constructing a very simple index basic mathematics to just understand what happens behind the scene so let's jump into it a database to be very simply put is just a collection of records like now if it's a sequel thing it could be the collection of rows grouped into tables if it's let's say mongodb or any document based database it would be like a collection of json documents but the idea is all of those documents needs to be stored in this so needs to be serialized and then stored onto the disk right so how does that serialization happen so in this one we'll take an example of a very simple uh a a very simple sequential serialization like here like what we typically see with sql databases right so let's take an example of sql database will not go dive will not go deeper into b plus tree and we'll see how it fits into the scheme of things but just a basic understanding of how indexes work so let's say we have a users table and it has five columns id name h bio and total blocks so every column or every attribute over here will take up some space onto the disk which means that when that attribute or when this row needs to be serialized every attribute gets its particular size or its particular set of bytes stored onto the disk right so here id being an integer let's say it takes up four bytes name i put it as 60 bytes age again an integers of 4 bytes bio could be a big one let's say we put it as 128 bytes and total number of blocks as in how many blocks has this user published would be an integer so four bytes so in all when i am trying to store one row onto the disk it would take up 200 bytes to store one disk uh to store one uh row okay so here we saw user table five columns 200 bytes to store one row onto the disk now let's say my table my users table has 100 rows like this so what would be the total size of this table 200 for each row 100 rows like this so 20 000 so basically 20 000 bytes is what will require so it would look something like this let's say these are like dummy entries in my table 1 name is a age is 23 some bio and then total number of blocks 7 id 2 name is b age is 21 bio something something something total blocks is 10 and so on and so forth right so let's say we are playing with this six entries and there are many more entries like this totaling up to 100 rows right now let's go through and understand how disk how reads from the disk actually happen so wherever anything is being read from the disk like even if you read one byte from the disk it's not that only that byte is red it's a block is read so your entire disk beat magnetic storage bit ssd it's split into blocks right and these blocks are consecutive in nature now a block can be like a standard configuration of block is typically 4 kb but you can change it you can make it you can make it bigger or you can make it smaller each one has its own set of consequence in this example let's take an example of our block size being 600 bytes which means if you have if you have let's say 1gb of hard disk on that 1gb of hard disk 600 bytes cup blocks uh like it is split into 600 byte blocks right and whenever like let's say i have this as a space and it is split into four blocks for now and let's say if i want to read these bytes which is highlighted in uh which is highlighted in yellow over here if i want to read these bytes it is not that i'll only be reading these bytes so when i'm doing a disk io the disk io will fetch the block that is contained or rather within which the bytes that i am requesting are content so here if i am requesting these bytes what your disk io will do is it will go to the disk like it will hit the disk read that particular block load it in memory read these bytes and then send it to the user right and basically send it for the further processing right so no matter how many bytes you would want to read it's not that only those bytes are read but the entire block is a brought into memory you read that many bytes and then you basically continue your processing right so block is the unit of data read from the disk right now let's see how our users table that we just discussed how that fits into my block string so we know that each record or each row of my users table is 200 bytes long we know that a block size for this example is 600 bytes right which means that in each block like if i am serializing this entire table in each block i can contain three rows so my users table would look something like this on disk so on disk i have these blocks the four blocks that we just discussed right so the first three rows will go and sit in the first block the second three rows will go and sit in the second block and so on and so forth because a block has like let's say a block has 600 bytes cup width like that's the size of the block each record is 200 bytes long so how many rows would we fit three rows so in this block we are putting in three rows in this block we are putting in three rows in this block we are putting a three dot and so on and so forth so to represent 100 no rather to store hundred rows on the disk how many blocks would you require we would require 100 by 3 it is 33.3 but we cannot like the block is not divisible so we need 34 blocks to store this entire table this entire table onto the disk this entire table onto the disk stored serially as a as a series of blocks which is total number of blocks required is 34 right now how much time now let's say if i am going through this table row by row how much time would it require for us to read this entire table so to read this entire table what would we require is we would have to iterate table row by row request a particular row the the your disk engine or your cpu in that case will identify hey i want to read this particular block from the disk it will go to the disk uh sorry it would say i want to read this particular row from the disk it would find the byte offset it would go on to the disk read that block keep in memory extract the record and basically use it for further processing so the amount of time that we would require to go through the entire table will be equal to the amount of time required for us to read those many number of blocks so because like hyper that very hypothetical example but let's say if i if i like when i do a disc i o and i'm reading one block let's say hypothetically it takes one second for us to read one block from the disk hypothetically it's it's much lower but hypothetically let's say it's one second so to read the entire table or to i trade through the entire table because we are reading 34 blocks how much time would it require for us to do it it will be 34 seconds because each block one second total 34 blocks so 34 seconds right so if i'm just iterating my table row by row it will it is taking me 34 seconds to do it now let's say we want to evaluate a query the query goes like this that find all the users with age 23 so what i typically have to do because up until now we have not added any indexes to this table what are we doing to do we will iterate the table row by row we will read the record we will see if this record has age 23 if it has we would we would basically put it in and buffer uh and then we would basically collating that buffer so we'll be iterating it row by row we would find all the rows with age 23 will check if the row has uh if the record has age equal to equal to 23 if yes we would add that record to an output buffer if no we would discard that particular record and then after the iteration of the table is done we would then written the output buffer as part of the response of my query right so now to do this how much time would it require because we are iterating the entire table we are rotating the entire table row by row which means we'll be accessing all 34 blocks so time taken for us to answer this query is same as time taken to read all the blocks of my table so because there are the d4 blocks it would require us 34 seconds to answer this query right because we are reading we are going through all of this thing now let's see how indexes make them make this particular flow faster so what exactly is an index index are very small referential tables that holds the row references against the indexed value right it's very simple concept so let's say we because we are querying or we want to query all users with h23 uh what we would want is we would want to create an index on column h so how does that index actually be stored onto the disk see this only knows block right so somehow your index will also be serialized and be stored onto the disk as blocks so an index is very similar to like an index to be honest is just a two dimensional oh sorry two-column table where the first column is h and the second column is id which means it's just a it's just like an it's just like a mapping from the indexed value to the row id or or to the row to in which that particular value is present so for example here age 23 so so age 23 is present for row id1 h21 is present for row id2 h22 is present in row id3 so here it's that only so h21 row id2 h22 raw id3 h22 is present at multiple places so h22 is present in row 85 is 23 is present in row id 1 age 23 is also present in row 84 and so on and so forth if you closely observe the column like your sorry your index is sorted is sorted by your indexed column which means it will be sorted by the uh by age in this case so 21 minute 23 24 so on and so forth right so this is exactly how your index will also be serialized will also be serialized and stored onto the disk right now let's see how much uh size or what's the width of like how much size would it require how many bytes would it require for you to store one entry of this index right so one entry of this index is what one h and one id age is an integer id is an integer so 4 plus 4 is equal to 8 bytes so each entry of this index is 8 byte bix so there will be how many entries in the index every row one entry in the index so total number of addresses is equal to 100 uh totals which means the total size of index is equal to 8 for each entry into 100 entries is equal to 800 bytes our one disk block is 600 bytes so how many disks how many disk block would we require to disk block right so for the as many entries as it can fill in one block it will put it all remaining address so first 600 bytes will be gone in first block remaining 200 bytes will go in second block so your index in order to represent your index onto your disk like if you are serializing your index and storing it",
  "title": "How do indexes make databases read faster?",
  "author": "Arpit Bhayani",
  "publish_date": "",
  "source": "YouTube",
  "language": "auto",
  "word_count": 2202,
  "extraction_method": "youtube",
  "extraction_timestamp": "2025-11-05T23:58:41.995810",
  "batch_id": "20251105_155409",
  "link_id": "yt_req2",
  "error": null
}