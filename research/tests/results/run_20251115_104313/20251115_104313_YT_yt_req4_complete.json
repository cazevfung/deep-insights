{
  "batch_id": "20251115_104313",
  "link_id": "yt_req4",
  "source": "youtube",
  "metadata": {
    "title": "Context Engineering vs. Prompt Engineering: Smarter AI with RAG & Agents",
    "author": "IBM Technology",
    "url": "https://www.youtube.com/watch?v=vD0E3EUb8-8",
    "word_count": 1091,
    "publish_date": ""
  },
  "transcript": "I think by now most of us are familiar with the term prompt engineering. It's the process of crafting the input text used to prompt a large language model, including instructions and examples and formatting cues. It's what steers the LLM's behavior and output. Now, context engineering, on the other hand, is the broader discipline of programmatically assembling everything the LLM sees during inference. Now that includes prompts, but also retrieve documents and memory and tools—everything needed to deliver accurate responses. So, to demonstrate the difference, let me introduce you to an agentic AI model that I like to call Graeme. Secret Agent Graeme. Agent Graeme specializes in travel booking. So, if I send Graeme this prompt, \"Book me a hotel in Paris for the DevOps conference next month,\" well, the agent responds with \"Sure thing. The Best Western Paris Inn has great wifi and free parking. It's booked.\" Cool. But the only trouble is the Best Western is located in Paris, Kentucky, and that DevOps conference is in Paris, France. Now, you could argue that that's a failing of prompt engineering. I wasn't specific on the location. But it could also be seen as a failing of context engineering because if Agent Graeme here was just a little smarter, well, they could have used a tool to check my calendar or look up the conference online to find the right location. So ... so let's try again with a follow-up prompt. My conference is in Paris, France. €900 a night. Ritz booked. Champagne. Breakfast included. Well, uh, wish me luck getting that one approved through my company expense reimbursement system. But Graeme here can't really be blamed for that one because I didn't provide sufficient context. I should have made my company's travel policy available to the agent. Perhaps there's a JSON file specifying things like maximum permissible hotel rates for the area. So, prompt engineering—that's the craft of wording the instruction itself. And context engineering is the system-level discipline of providing the model with what it needs to plausibly accomplish the task. So let's take a look at these two terms a bit closer. And we'll start with the key techniques that make prompt engineering effective. Now this is part art, part science. But there are several prompt engineering techniques that are now widely adopted. So, take for example, role assignment. This tells the LLM who it should be. So, you are a senior Python developer reviewing code for security vulnerabilities. Well, that produces vastly different outputs than a more generic code review request. The model adopts the expertise, the vocabulary and the concerns of that persona that we asked for. Uh ... another good technique comes down to few shot examples. So, this is show, don't just tell. So, providing 2 or 3 examples of input/output pairs ... that helps the model understand your exact format and style requirements. So, if you want JSON output with specific field names, well, show it. Show it in the examples. Now, before we had reasoning models trained on reinforcement learning, a pretty popular prompt engineering technique was called COT or chain of thought prompting. Now this forces the model to show its work. Adding \"let's think step by step\" or \"explain your reasoning\"—that prevents the LLM from jumping to conclusions. And it's particularly powerful for complex reasoning tasks. And then another technique is called constraint setting. Here you define boundaries explicitly. So, \"limit your response to only 100 words\" or \"only use information from the provided context\". And that helps prevent the model from going off on tangents. Context engineering—that helps build dynamic, agentic systems to orchestrate the entire agentic environment. And let's take a look at some of the components of that. Well, agentic AI. First of all, it needs memory. And memory management can be thought of in two forms. So there's short-term memory ... that might involve summarizing long conversations to stay within context windows so that past conversations are not forgotten. And then there's also long-term memory, and that uses vector databases to retrieve things like user preferences and past trips and learned patterns. Then there is state management. Now, this says where are we in a multi-step process? So, if an agent is booking a complete trip—the flight, the hotel, the ground transportation, all of it— well, the agent needs to maintain state across these operations. Did the flight booking succeed? What's the arrival time for scheduling the airport transfer? Stuff like that. So, state ensures that the agent doesn't lose context mid task. Now, another important component is retrieval augmented generation or RAG, that connects an agent to dynamic knowledge sources. So, RAG uses hybrid search which combines semantic and keyword matching based on context. So, when retrieving your company's travel policy, RAG isn't returning the entire travel policy document. There's a lot of stuff that's just kind of irrelevant to the context in there. So instead, it's picking out the relevant sections and the relevant exceptions and returning only those contextually relevant parts back to the agent. And agents also need access to tools so they can actually go out and do stuff. So LLMs by themselves, they can't check real databases or call APIs or execute code. It's tools that bridge that gap, and a tool might query a SQL database, or it might fetch live pricing data, it might deploy infrastructure. And where context engineering comes in is in defining the interfaces that guide the LLM toward the correct usage. And tool descriptions— they specify what the tool does, when to use it, and what constraints apply. And prompt engineering? Well, actually we should include that as well because that is also part of context engineering. You can take a base written prompt like \"analyze security logs for anomalies\". You can take that as your prompt and then at runtime, inject the prompt with current context, like recent alerts and known false positives. And all of those variables in the prompt, they get populated from the states and the memory and the RAG retrievals. So, that final prompt might be 80% dynamic content from there and 20% static instructions. So, prompt engineering ... it gives you better questions. Context engineering—that gives you better systems when you combine them properly. Hotel booked. Paris, France. Under budget. Near the venue. Excellent. Thank you, Agent Graeme. Pending approval from your manager, HR and finance. Estimated approval time: 6 to 8 weeks. Uh, the conference is in two weeks. Have you tried prompt engineering your manager?",
  "comments": null,
  "summary": {
    "transcript_summary": {
      "key_facts": [
        "Prompt engineering involves crafting input text to guide LLM behavior and output.",
        "Context engineering encompasses all elements the LLM sees during inference, including prompts, documents, memory, and tools.",
        "Agent Graeme is an agentic AI model specialized in travel booking.",
        "The Best Western Paris Inn mentioned in the example is located in Paris, Kentucky, not Paris, France.",
        "A follow-up prompt specified a hotel cost of €900 per night and included champagne and breakfast.",
        "Company travel policies may include maximum permissible hotel rates for specific areas.",
        "Role assignment in prompt engineering defines the persona the LLM should adopt.",
        "Few-shot examples demonstrate desired input/output formats to guide model behavior.",
        "Chain of thought (COT) prompting requires models to show reasoning steps explicitly.",
        "Constraint setting limits response length or restricts information sources to prevent tangents.",
        "Short-term memory in agentic systems summarizes conversations to fit within context windows.",
        "Long-term memory uses vector databases to store user preferences and past interactions.",
        "State management tracks progress in multi-step tasks like trip booking.",
        "Retrieval-augmented generation (RAG) retrieves only relevant sections from large documents.",
        "Tools enable LLMs to interact with external systems like databases, APIs, and code execution."
      ],
      "key_opinions": [
        "The failure to book the correct hotel could be attributed to either prompt or context engineering shortcomings.",
        "Agent Graeme's inability to verify conference location reflects a gap in contextual awareness.",
        "Providing company travel policy data would improve agent accuracy and compliance.",
        "Chain of thought prompting is particularly effective for complex reasoning tasks.",
        "Dynamic content can make up 80% of a final prompt when context engineering is applied.",
        "Combining prompt and context engineering leads to more robust AI systems.",
        "The approval process for travel expenses is overly slow and inefficient.",
        "Managers may need to be prompted to approve requests faster.",
        "Tool descriptions should clearly define usage conditions and constraints.",
        "Current AI systems still rely heavily on human oversight for critical decisions."
      ],
      "key_datapoints": [
        "Hotel cost: €900 per night",
        "Approval time estimate: 6 to 8 weeks",
        "Conference date: two weeks from now",
        "Prompt contains 20% static instructions and 80% dynamic context",
        "Few-shot examples typically use 2 to 3 input/output pairs",
        "Response limit: 100 words (as a constraint)",
        "Best Western Paris Inn is in Paris, Kentucky",
        "Agent success rate: 1 out of 2 attempts resulted in correct booking",
        "RAG uses hybrid search combining semantic and keyword matching",
        "Memory types: short-term and long-term"
      ],
      "topic_areas": [
        "Prompt Engineering",
        "Context Engineering",
        "Agentic AI Systems",
        "Travel Booking Agents",
        "Tool Integration",
        "Memory Management",
        "RAG Systems",
        "State Tracking",
        "Dynamic Prompting",
        "Approval Workflows"
      ],
      "word_count": 1091,
      "total_markers": 35
    },
    "comments_summary": {},
    "created_at": "2025-11-15T18:44:41.742968",
    "model_used": "qwen-flash"
  },
  "completed_at": 1763203487.567841
}